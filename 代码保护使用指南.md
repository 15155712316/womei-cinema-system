# 代码保护使用指南

## 🎯 快速开始

### 方法一：一键安全构建（推荐）

```bash
# 执行完整的安全构建流程
python secure_build.py
```

这个脚本会自动完成：
1. ✅ 备份源代码
2. ✅ 安装保护工具
3. ✅ 混淆代码
4. ✅ 加密配置文件
5. ✅ 添加安全特性
6. ✅ 构建可执行文件
7. ✅ 清理临时文件

### 方法二：分步执行

```bash
# 1. 保护源代码
python protect_source_code.py

# 2. 进入保护目录
cd protected_source

# 3. 构建可执行文件
python build_protected.py
```

---

## 📁 输出文件说明

### 安全构建后的目录结构

```
项目根目录/
├── source_backup/           # 原始源码备份（重要！）
├── secure_dist/            # 安全构建输出
│   └── CinemaTicketSystem/ # 可分发的程序
└── [原始项目文件]         # 保持不变
```

### 分发内容

**只分发这个目录**：
```
secure_dist/CinemaTicketSystem/
├── CinemaTicketSystem.exe  # 保护后的主程序
├── data/                   # 加密的配置文件
└── [其他依赖文件]         # PyQt5运行时等
```

---

## 🔒 保护级别说明

### 当前实现的保护措施

1. **代码混淆** (PyArmor)
   - ✅ Python字节码混淆
   - ✅ 字符串加密
   - ✅ 导入保护
   - ✅ JIT保护

2. **配置加密**
   - ✅ 配置文件XOR加密
   - ✅ 基于机器特征的密钥
   - ✅ 运行时动态解密

3. **反调试保护**
   - ✅ 调试器检测
   - ✅ 虚拟机检测
   - ✅ 后台监控线程

4. **完整性保护**
   - ✅ 源码备份隔离
   - ✅ 临时文件清理
   - ✅ 构建环境隔离

### 保护效果评估

| 攻击类型 | 保护效果 | 说明 |
|----------|----------|------|
| 普通用户好奇 | 🟢 完全阻止 | 无法轻易查看源码 |
| 简单工具反编译 | 🟢 完全阻止 | pyinstxtractor等失效 |
| 专业逆向工具 | 🟡 显著增加难度 | 需要专业知识和时间 |
| 高级APT攻击 | 🟠 部分保护 | 仍有被破解可能 |

---

## ⚙️ 高级配置

### 自定义保护参数

编辑 `protect_source_code.py` 中的混淆参数：

```python
# 基础保护
cmd = ['pyarmor', 'obfuscate', '--recursive', '--restrict', '0']

# 增强保护（需要PyArmor Pro）
cmd = [
    'pyarmor', 'obfuscate',
    '--recursive',
    '--restrict', '0',
    '--enable-jit',          # JIT保护
    '--mix-str',             # 字符串混淆
    '--obf-code', '2',       # 代码混淆级别
    '--wrap-mode', '1',      # 包装模式
    '--advanced'             # 高级保护
]
```

### 自定义加密密钥

修改 `config_encryption.py` 中的密钥生成：

```python
def _generate_machine_key(self) -> bytes:
    # 使用自定义的密钥生成逻辑
    custom_key = "your_custom_key_here"
    return hashlib.sha256(custom_key.encode()).digest()
```

### 添加自定义安全检查

在 `security_manager.py` 中添加：

```python
def custom_security_check(self):
    # 添加您的自定义安全检查
    # 例如：检查特定文件、网络环境等
    pass
```

---

## 🚨 重要注意事项

### 安全提醒

1. **备份管理**
   - ⚠️ 妥善保管 `source_backup` 目录
   - ⚠️ 不要将备份与分发包一起发送
   - ⚠️ 定期备份到安全位置

2. **分发安全**
   - ✅ 只分发 `secure_dist` 目录
   - ❌ 不要分发 `protected_source` 目录
   - ❌ 不要分发原始源码

3. **密钥安全**
   - 🔑 加密密钥基于机器特征生成
   - 🔑 不同机器的密钥不同
   - 🔑 考虑使用服务器端密钥管理

### 技术限制

1. **Python语言特性**
   - Python是解释型语言，完全保护不可能
   - 保护只是增加破解难度和成本
   - 专业攻击者仍有可能破解

2. **性能影响**
   - 混淆可能轻微影响启动速度
   - 加密解密会消耗少量CPU
   - 安全检查会占用少量内存

3. **兼容性考虑**
   - 反调试可能与某些安全软件冲突
   - 虚拟机检测可能误报
   - 需要在目标环境充分测试

---

## 🔧 故障排除

### 常见问题

1. **PyArmor安装失败**
   ```bash
   # 使用国内镜像
   pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyarmor
   ```

2. **混淆后程序无法运行**
   ```bash
   # 检查是否有动态导入
   # 在hiddenimports中添加相关模块
   ```

3. **配置文件加密失败**
   ```bash
   # 安装加密库
   pip install cryptography
   ```

4. **反调试误报**
   ```python
   # 在security_manager.py中调整检测逻辑
   # 或临时禁用某些检查
   ```

### 调试模式

临时禁用保护进行调试：

```python
# 在main_modular.py开头添加
DEBUG_MODE = True

if not DEBUG_MODE:
    from security_manager import security_manager
    security_manager.start_monitoring()
```

---

## 📈 升级路径

### 短期改进（1个月内）

1. **购买PyArmor Pro**
   - 更强的混淆能力
   - 硬件绑定支持
   - 在线验证功能

2. **服务器端验证**
   - 关键功能服务器验证
   - 动态密钥分发
   - 使用统计和监控

### 中期改进（3-6个月）

1. **核心算法迁移**
   - 敏感算法移至服务器
   - 客户端仅保留UI逻辑
   - API接口加密通信

2. **白盒加密**
   - 使用白盒加密技术
   - 密钥隐藏在代码中
   - 抗密钥提取攻击

### 长期规划（6个月以上）

1. **C++核心重写**
   - 关键模块用C++实现
   - Python仅用于UI
   - 编译为本地代码

2. **硬件安全模块**
   - 使用HSM存储密钥
   - 硬件级别的保护
   - 企业级安全方案

---

## 📞 技术支持

### 获取帮助

1. **文档资源**
   - PyArmor官方文档
   - Python加密最佳实践
   - 软件保护技术指南

2. **社区支持**
   - GitHub Issues
   - Stack Overflow
   - 专业安全论坛

3. **商业支持**
   - PyArmor Pro技术支持
   - 专业安全咨询服务
   - 定制化保护方案

---

**记住**：代码保护是一个持续的过程，需要根据威胁环境的变化不断调整和改进保护策略。
