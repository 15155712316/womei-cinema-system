# PyQt5电影票务管理系统 - 用户管理和设备绑定完整解决方案

## 📋 **方案概览**

**目标用户规模**：50-100个用户
**核心需求**：设备唯一绑定 + 在线管理后台 + 客户端分发
**技术架构**：PyQt5客户端 + Flask API服务器 + MongoDB数据库 + Web管理后台
**安全机制**：手机号+机器码双重验证，确保一账号一设备

---

## 🏗️ **1. 系统架构设计**

### **1.1 整体架构图**
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   PyQt5客户端    │    │   Flask API     │    │   MongoDB数据库  │
│                 │    │                 │    │                 │
│ • 登录界面      │◄──►│ • 用户认证      │◄──►│ • 用户数据      │
│ • 机器码获取    │    │ • 设备绑定      │    │ • 设备绑定      │
│ • 业务功能      │    │ • 权限验证      │    │ • 登录日志      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌─────────────────┐
                       │   Web管理后台    │
                       │                 │
                       │ • 用户管理      │
                       │ • 设备管理      │
                       │ • 积分管理      │
                       │ • 统计分析      │
                       └─────────────────┘
```

### **1.2 核心组件职责**

#### **PyQt5客户端**
- **登录验证**：手机号输入 + 自动机器码获取
- **设备绑定**：首次登录自动绑定当前设备
- **业务功能**：电影票务管理核心功能
- **离线缓存**：用户信息本地缓存机制

#### **Flask API服务器**
- **用户认证**：手机号+机器码验证
- **设备管理**：设备绑定、解绑、重绑
- **权限控制**：用户状态、积分管理
- **安全防护**：防刷机制、异常检测

#### **MongoDB数据库**
- **用户数据**：基础信息、状态、积分
- **设备绑定**：机器码、绑定时间、设备信息
- **操作日志**：登录记录、操作审计
- **系统配置**：全局设置、权限配置

#### **Web管理后台**
- **用户管理**：CRUD操作、批量管理
- **设备管理**：绑定查看、强制解绑
- **数据统计**：用户活跃度、设备分布
- **系统监控**：API调用、异常告警

---

## 🔧 **2. 数据库设计优化**

### **2.1 用户数据结构设计**
```javascript
// MongoDB用户集合结构
{
  "_id": ObjectId("..."),
  "userId": "user_15155712316",           // 用户唯一标识
  "phone": "15155712316",                 // 手机号（登录凭证）
  "profile": {
    "displayName": "用户15155712316",      // 显示名称
    "nickname": null,                     // 昵称（可选）
    "avatar": null,                       // 头像URL（可选）
    "email": null                         // 邮箱（可选）
  },
  "account": {
    "points": 100,                        // 积分余额
    "level": "普通用户",                   // 用户等级
    "status": {
      "code": 1,                          // 状态码：1=正常，0=禁用，-1=冻结
      "text": "正常",                      // 状态文本
      "reason": null,                     // 状态变更原因
      "updatedAt": ISODate("...")         // 状态更新时间
    },
    "permissions": ["login", "order", "payment"], // 权限列表
    "subscription": {
      "type": "basic",                    // 订阅类型
      "expiresAt": null                   // 过期时间
    }
  },
  "device": {
    "machineCode": "9DC6B72833DBFDA6",    // 绑定的机器码
    "deviceInfo": {
      "os": "Windows 10",                 // 操作系统
      "hostname": "USER-PC",              // 计算机名
      "cpu": "Intel Core i5",             // CPU信息
      "memory": "8GB"                     // 内存信息
    },
    "bindTime": ISODate("..."),           // 绑定时间
    "lastLoginTime": ISODate("..."),      // 最后登录时间
    "loginCount": 25,                     // 登录次数
    "isOnline": false                     // 是否在线
  },
  "security": {
    "loginAttempts": 0,                   // 登录尝试次数
    "lastFailedLogin": null,              // 最后失败登录时间
    "lockUntil": null,                    // 锁定到期时间
    "ipWhitelist": [],                    // IP白名单
    "suspiciousActivity": []              // 可疑活动记录
  },
  "metadata": {
    "createdAt": ISODate("..."),          // 创建时间
    "updatedAt": ISODate("..."),          // 更新时间
    "createdBy": "admin",                 // 创建者
    "source": "manual"                    // 创建来源：manual/import/api
  }
}
```

### **2.2 登录日志结构设计**
```javascript
// 登录日志集合
{
  "_id": ObjectId("..."),
  "userId": "user_15155712316",
  "phone": "15155712316",
  "loginTime": ISODate("..."),
  "loginResult": "success",               // success/failed/blocked
  "machineCode": "9DC6B72833DBFDA6",
  "deviceInfo": {
    "os": "Windows 10",
    "ip": "192.168.1.100",
    "userAgent": "PyQt5 Client v1.0"
  },
  "failureReason": null,                  // 失败原因
  "sessionDuration": 3600,                // 会话时长（秒）
  "logoutTime": ISODate("..."),           // 登出时间
  "logoutReason": "manual"                // 登出原因
}
```

### **2.3 数据库索引优化**
```javascript
// 必需索引
db.users.createIndex({"phone": 1}, {"unique": true})
db.users.createIndex({"device.machineCode": 1})
db.users.createIndex({"account.status.code": 1})
db.users.createIndex({"device.lastLoginTime": -1})
db.users.createIndex({"metadata.createdAt": -1})

// 复合索引
db.users.createIndex({"phone": 1, "account.status.code": 1})
db.users.createIndex({"device.machineCode": 1, "account.status.code": 1})

// 登录日志索引
db.loginLogs.createIndex({"userId": 1, "loginTime": -1})
db.loginLogs.createIndex({"phone": 1, "loginTime": -1})
db.loginLogs.createIndex({"machineCode": 1, "loginTime": -1})
db.loginLogs.createIndex({"loginTime": -1})
```

---

## 🚀 **3. API接口优化方案**

### **3.1 登录API优化实现**
```python
# api_v2.py - 优化后的登录API
from flask import Flask, request, jsonify
from pymongo import MongoClient
from datetime import datetime, timedelta
import jwt
import hashlib
import platform
import socket
import time

class UserAuthAPI:
    def __init__(self):
        self.client = MongoClient("mongodb://userdb:userdb@127.0.0.1:27017/userdb")
        self.db = self.client["userdb"]
        self.users = self.db["users"]
        self.login_logs = self.db["loginLogs"]
        self.jwt_secret = "your-jwt-secret-key"

    def login(self, request_data):
        """优化的登录API"""
        try:
            # 1. 参数验证
            phone = request_data.get("phone")
            machine_code = request_data.get("machineCode")
            device_info = request_data.get("deviceInfo", {})

            if not phone or not machine_code:
                return self._error_response("手机号和机器码不能为空", 400)

            # 2. 手机号格式验证
            if not self._validate_phone(phone):
                return self._error_response("手机号格式不正确", 400)

            # 3. 查找用户
            user = self.users.find_one({"phone": phone})
            if not user:
                self._log_login_attempt(phone, machine_code, "failed", "用户不存在")
                return self._error_response("手机号未注册，请联系管理员", 403)

            # 4. 账号状态检查
            if user.get("account", {}).get("status", {}).get("code", 1) != 1:
                status_reason = user.get("account", {}).get("status", {}).get("reason", "账号被禁用")
                self._log_login_attempt(phone, machine_code, "blocked", status_reason)
                return self._error_response(f"账号已被禁用：{status_reason}", 403)

            # 5. 设备绑定验证
            bind_result = self._verify_device_binding(user, machine_code, device_info)
            if not bind_result["success"]:
                self._log_login_attempt(phone, machine_code, "failed", bind_result["message"])
                return self._error_response(bind_result["message"], 403)

            # 6. 更新用户登录信息
            self._update_user_login_info(user["_id"], machine_code, device_info)

            # 7. 生成JWT Token
            token = self._generate_jwt_token(user)

            # 8. 记录成功登录
            self._log_login_attempt(phone, machine_code, "success", "登录成功")

            # 9. 构建响应数据
            response_data = self._build_login_response(user, token)

            return self._success_response(response_data, "登录成功")

        except Exception as e:
            print(f"登录API异常: {e}")
            return self._error_response("服务器内部错误", 500)

    def _verify_device_binding(self, user, machine_code, device_info):
        """验证设备绑定"""
        user_machine_code = user.get("device", {}).get("machineCode")

        if not user_machine_code:
            # 首次登录，绑定设备
            return {"success": True, "action": "bind"}
        elif user_machine_code == machine_code:
            # 设备匹配
            return {"success": True, "action": "verify"}
        else:
            # 设备不匹配
            return {
                "success": False,
                "message": f"设备未授权，当前设备机器码与绑定设备不匹配\n请联系管理员重新绑定设备"
            }

    def _update_user_login_info(self, user_id, machine_code, device_info):
        """更新用户登录信息"""
        update_data = {
            "device.machineCode": machine_code,
            "device.lastLoginTime": datetime.now(),
            "device.isOnline": True,
            "metadata.updatedAt": datetime.now()
        }

        # 更新设备信息
        if device_info:
            update_data.update({
                "device.deviceInfo.os": device_info.get("os", "Unknown"),
                "device.deviceInfo.hostname": device_info.get("hostname", "Unknown"),
                "device.deviceInfo.ip": device_info.get("ip", "Unknown")
            })

        # 增加登录次数
        self.users.update_one(
            {"_id": user_id},
            {
                "$set": update_data,
                "$inc": {"device.loginCount": 1}
            }
        )

    def _generate_jwt_token(self, user):
        """生成JWT Token"""
        payload = {
            "userId": str(user["_id"]),
            "phone": user["phone"],
            "iat": int(time.time()),
            "exp": int(time.time()) + 86400  # 24小时过期
        }
        return jwt.encode(payload, self.jwt_secret, algorithm="HS256")

    def _build_login_response(self, user, token):
        """构建登录响应数据"""
        return {
            "userId": str(user["_id"]),
            "profile": {
                "phone": user["phone"],
                "displayName": user.get("profile", {}).get("displayName", f"用户{user['phone']}"),
                "nickname": user.get("profile", {}).get("nickname"),
                "avatar": user.get("profile", {}).get("avatar")
            },
            "account": {
                "points": user.get("account", {}).get("points", 0),
                "level": user.get("account", {}).get("level", "普通用户"),
                "status": user.get("account", {}).get("status", {"code": 1, "text": "正常"}),
                "permissions": user.get("account", {}).get("permissions", ["login", "order"])
            },
            "device": {
                "machineCode": user.get("device", {}).get("machineCode"),
                "bindTime": user.get("device", {}).get("bindTime"),
                "lastLoginTime": user.get("device", {}).get("lastLoginTime"),
                "loginCount": user.get("device", {}).get("loginCount", 0)
            },
            "auth": {
                "token": token,
                "expiresIn": 86400,
                "tokenType": "Bearer"
            },
            # 兼容性字段（保持现有客户端正常工作）
            "phone": user["phone"],
            "username": user["phone"],
            "points": user.get("account", {}).get("points", 0),
            "status": user.get("account", {}).get("status", {}).get("code", 1),
            "machineCode": user.get("device", {}).get("machineCode")
        }

    def _log_login_attempt(self, phone, machine_code, result, reason):
        """记录登录尝试"""
        log_entry = {
            "phone": phone,
            "machineCode": machine_code,
            "loginTime": datetime.now(),
            "loginResult": result,
            "failureReason": reason if result != "success" else None,
            "deviceInfo": {
                "os": platform.system(),
                "ip": request.environ.get('HTTP_X_FORWARDED_FOR', request.environ.get('REMOTE_ADDR', 'Unknown'))
            }
        }
        self.login_logs.insert_one(log_entry)

    def _validate_phone(self, phone):
        """验证手机号格式"""
        import re
        pattern = r'^1[3-9]\d{9}$'
        return re.match(pattern, phone) is not None

    def _success_response(self, data, message="操作成功"):
        """成功响应格式"""
        return {
            "success": True,
            "message": message,
            "data": data,
            "timestamp": datetime.now().isoformat()
        }

    def _error_response(self, message, code=400):
        """错误响应格式"""
        return {
            "success": False,
            "message": message,
            "error_code": code,
            "timestamp": datetime.now().isoformat()
        }

# Flask路由集成
app = Flask(__name__)
auth_api = UserAuthAPI()

@app.route("/api/v2/login", methods=["POST"])
def login_v2():
    """新版本登录API"""
    return jsonify(auth_api.login(request.json))
```

### **3.2 设备管理API**
```python
class DeviceManagementAPI:
    def __init__(self, db):
        self.users = db["users"]
        self.login_logs = db["loginLogs"]

    def unbind_device(self, phone, admin_reason="管理员操作"):
        """解绑用户设备"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"success": False, "message": "用户不存在"}

            # 解绑设备
            self.users.update_one(
                {"phone": phone},
                {
                    "$unset": {"device.machineCode": ""},
                    "$set": {
                        "device.unbindTime": datetime.now(),
                        "device.unbindReason": admin_reason,
                        "device.isOnline": False,
                        "metadata.updatedAt": datetime.now()
                    }
                }
            )

            return {"success": True, "message": "设备解绑成功"}

        except Exception as e:
            return {"success": False, "message": f"解绑失败: {str(e)}"}

    def rebind_device(self, phone, new_machine_code, admin_reason="管理员重新绑定"):
        """重新绑定用户设备"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"success": False, "message": "用户不存在"}

            # 重新绑定设备
            self.users.update_one(
                {"phone": phone},
                {
                    "$set": {
                        "device.machineCode": new_machine_code,
                        "device.bindTime": datetime.now(),
                        "device.rebindReason": admin_reason,
                        "device.isOnline": False,
                        "metadata.updatedAt": datetime.now()
                    }
                }
            )

            return {"success": True, "message": "设备重新绑定成功"}

        except Exception as e:
            return {"success": False, "message": f"重新绑定失败: {str(e)}"}

    def get_device_info(self, phone):
        """获取用户设备信息"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"success": False, "message": "用户不存在"}

            device_info = user.get("device", {})
            return {
                "success": True,
                "data": {
                    "machineCode": device_info.get("machineCode"),
                    "deviceInfo": device_info.get("deviceInfo", {}),
                    "bindTime": device_info.get("bindTime"),
                    "lastLoginTime": device_info.get("lastLoginTime"),
                    "loginCount": device_info.get("loginCount", 0),
                    "isOnline": device_info.get("isOnline", False)
                }
            }

        except Exception as e:
            return {"success": False, "message": f"获取设备信息失败: {str(e)}"}

# Flask路由
device_api = DeviceManagementAPI(auth_api.db)

@app.route("/api/v2/admin/device/unbind", methods=["POST"])
def unbind_device():
    """解绑设备API"""
    data = request.json
    phone = data.get("phone")
    reason = data.get("reason", "管理员操作")
    return jsonify(device_api.unbind_device(phone, reason))

@app.route("/api/v2/admin/device/rebind", methods=["POST"])
def rebind_device():
    """重新绑定设备API"""
    data = request.json
    phone = data.get("phone")
    machine_code = data.get("machineCode")
    reason = data.get("reason", "管理员重新绑定")
    return jsonify(device_api.rebind_device(phone, machine_code, reason))
```

---

## 🖥️ **4. 客户端适配优化**

### **4.1 增强的机器码获取**
```python
# utils/machine_code_enhanced.py
import platform
import subprocess
import hashlib
import socket
import uuid
import psutil
from typing import Dict, Optional

class EnhancedMachineCodeGenerator:
    """增强的机器码生成器"""

    def __init__(self):
        self.cache_file = "machine_info.cache"
        self._cached_info = None

    def get_machine_code(self) -> str:
        """获取机器码（主方法）"""
        try:
            # 尝试从缓存获取
            if self._cached_info:
                return self._cached_info["machineCode"]

            # 生成新的机器码
            machine_info = self._collect_machine_info()
            machine_code = self._generate_machine_code(machine_info)

            # 缓存机器信息
            self._cached_info = {
                "machineCode": machine_code,
                "machineInfo": machine_info,
                "generatedAt": datetime.now().isoformat()
            }

            self._save_cache()
            return machine_code

        except Exception as e:
            print(f"获取机器码失败: {e}")
            # 返回备用机器码
            return self._get_fallback_machine_code()

    def get_device_info(self) -> Dict:
        """获取详细设备信息"""
        try:
            return {
                "os": f"{platform.system()} {platform.release()}",
                "hostname": socket.gethostname(),
                "cpu": self._get_cpu_info(),
                "memory": self._get_memory_info(),
                "disk": self._get_disk_info(),
                "network": self._get_network_info(),
                "machineCode": self.get_machine_code()
            }
        except Exception as e:
            print(f"获取设备信息失败: {e}")
            return {
                "os": "Unknown",
                "hostname": "Unknown",
                "machineCode": self.get_machine_code()
            }

    def _collect_machine_info(self) -> Dict:
        """收集机器信息"""
        info = {}

        try:
            # 基础系统信息
            info["platform"] = platform.platform()
            info["machine"] = platform.machine()
            info["processor"] = platform.processor()
            info["hostname"] = socket.gethostname()

            # MAC地址
            info["mac"] = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff)
                                   for elements in range(0,2*6,2)][::-1])

            # CPU信息
            if hasattr(psutil, 'cpu_count'):
                info["cpu_count"] = psutil.cpu_count()

            # 内存信息
            if hasattr(psutil, 'virtual_memory'):
                memory = psutil.virtual_memory()
                info["memory_total"] = memory.total

            # 磁盘序列号（Windows）
            if platform.system() == "Windows":
                try:
                    result = subprocess.run(
                        ["wmic", "diskdrive", "get", "serialnumber"],
                        capture_output=True, text=True, timeout=5
                    )
                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        for line in lines[1:]:  # 跳过标题行
                            serial = line.strip()
                            if serial and serial != "SerialNumber":
                                info["disk_serial"] = serial
                                break
                except Exception:
                    pass

            # 主板序列号（Windows）
            if platform.system() == "Windows":
                try:
                    result = subprocess.run(
                        ["wmic", "baseboard", "get", "serialnumber"],
                        capture_output=True, text=True, timeout=5
                    )
                    if result.returncode == 0:
                        lines = result.stdout.strip().split('\n')
                        for line in lines[1:]:
                            serial = line.strip()
                            if serial and serial != "SerialNumber":
                                info["motherboard_serial"] = serial
                                break
                except Exception:
                    pass

        except Exception as e:
            print(f"收集机器信息失败: {e}")

        return info

    def _generate_machine_code(self, machine_info: Dict) -> str:
        """生成机器码"""
        # 选择最稳定的硬件标识符
        identifiers = []

        # 优先级顺序：主板序列号 > 磁盘序列号 > MAC地址 > 主机名
        if "motherboard_serial" in machine_info:
            identifiers.append(machine_info["motherboard_serial"])

        if "disk_serial" in machine_info:
            identifiers.append(machine_info["disk_serial"])

        if "mac" in machine_info:
            identifiers.append(machine_info["mac"])

        if "hostname" in machine_info:
            identifiers.append(machine_info["hostname"])

        # 添加系统信息作为辅助标识
        identifiers.extend([
            machine_info.get("platform", ""),
            machine_info.get("processor", ""),
            str(machine_info.get("memory_total", ""))
        ])

        # 生成哈希
        combined = "|".join(filter(None, identifiers))
        hash_obj = hashlib.sha256(combined.encode('utf-8'))

        # 返回16位大写十六进制
        return hash_obj.hexdigest()[:16].upper()

    def _get_fallback_machine_code(self) -> str:
        """获取备用机器码"""
        try:
            # 使用MAC地址作为备用
            mac = uuid.getnode()
            return f"{mac:012X}"[:16]
        except:
            # 最后的备用方案
            return "DEFAULT12345678"

    def _get_cpu_info(self) -> str:
        """获取CPU信息"""
        try:
            if platform.system() == "Windows":
                result = subprocess.run(
                    ["wmic", "cpu", "get", "name"],
                    capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines[1:]:
                        cpu_name = line.strip()
                        if cpu_name and cpu_name != "Name":
                            return cpu_name
            return platform.processor() or "Unknown CPU"
        except:
            return "Unknown CPU"

    def _get_memory_info(self) -> str:
        """获取内存信息"""
        try:
            if hasattr(psutil, 'virtual_memory'):
                memory = psutil.virtual_memory()
                gb = memory.total / (1024**3)
                return f"{gb:.1f}GB"
            return "Unknown"
        except:
            return "Unknown"

    def _get_disk_info(self) -> str:
        """获取磁盘信息"""
        try:
            if hasattr(psutil, 'disk_usage'):
                disk = psutil.disk_usage('/')
                gb = disk.total / (1024**3)
                return f"{gb:.1f}GB"
            return "Unknown"
        except:
            return "Unknown"

    def _get_network_info(self) -> str:
        """获取网络信息"""
        try:
            hostname = socket.gethostname()
            ip = socket.gethostbyname(hostname)
            return f"{hostname} ({ip})"
        except:
            return "Unknown"

    def _save_cache(self):
        """保存缓存"""
        try:
            import json
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(self._cached_info, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"保存机器码缓存失败: {e}")

    def _load_cache(self):
        """加载缓存"""
        try:
            import json
            with open(self.cache_file, 'r', encoding='utf-8') as f:
                self._cached_info = json.load(f)
        except:
            self._cached_info = None

# 全局实例
enhanced_machine_code = EnhancedMachineCodeGenerator()
```

### **4.2 优化的认证服务**
```python
# services/auth_service_enhanced.py
import requests
import json
import time
from typing import Tuple, Optional, Dict
from utils.machine_code_enhanced import enhanced_machine_code

class EnhancedAuthService:
    """增强的认证服务"""

    def __init__(self, api_base_url: str = "http://your-server:5000"):
        self.api_base_url = api_base_url.rstrip('/')
        self.current_user = None
        self.session_token = None
        self.token_expires_at = 0
        self.machine_code_generator = enhanced_machine_code

    def login(self, phone: str) -> Tuple[bool, str, Optional[Dict]]:
        """增强的登录方法"""
        try:
            # 1. 验证手机号格式
            if not self._validate_phone(phone):
                return False, "请输入正确的手机号码", None

            # 2. 获取机器码和设备信息
            machine_code = self.machine_code_generator.get_machine_code()
            device_info = self.machine_code_generator.get_device_info()

            print(f"[登录] 手机号: {phone}")
            print(f"[登录] 机器码: {machine_code}")
            print(f"[登录] 设备信息: {device_info['os']} - {device_info['hostname']}")

            # 3. 构建登录请求
            login_data = {
                "phone": phone,
                "machineCode": machine_code,
                "deviceInfo": {
                    "os": device_info["os"],
                    "hostname": device_info["hostname"],
                    "ip": self._get_local_ip(),
                    "userAgent": "PyQt5 Client v2.0"
                },
                "timestamp": int(time.time())
            }

            # 4. 发送登录请求
            response = self._call_api("/api/v2/login", login_data, method="POST")

            if response.get("success"):
                user_info = response.get("data", {})

                # 5. 保存认证信息
                self.current_user = user_info
                self.session_token = user_info.get("auth", {}).get("token")
                self.token_expires_at = int(time.time()) + user_info.get("auth", {}).get("expiresIn", 86400)

                # 6. 保存到本地缓存
                self._save_user_cache(user_info)

                print(f"[登录] 登录成功")
                print(f"[登录] 用户: {user_info.get('profile', {}).get('displayName')}")
                print(f"[登录] 积分: {user_info.get('account', {}).get('points')}")
                print(f"[登录] 状态: {user_info.get('account', {}).get('status', {}).get('text')}")

                return True, "登录成功", user_info
            else:
                error_msg = response.get("message", "登录失败")
                print(f"[登录] 登录失败: {error_msg}")
                return False, error_msg, None

        except requests.exceptions.ConnectionError:
            return False, "无法连接到服务器，请检查网络连接", None
        except requests.exceptions.Timeout:
            return False, "连接超时，请稍后重试", None
        except Exception as e:
            print(f"[登录] 登录异常: {e}")
            return False, f"登录异常: {str(e)}", None

    def check_auth(self) -> Tuple[bool, str, Optional[Dict]]:
        """检查认证状态"""
        try:
            # 1. 检查本地登录状态
            if not self.current_user or not self.session_token:
                return False, "未登录", None

            # 2. 检查Token是否过期
            if int(time.time()) >= self.token_expires_at:
                print("[认证] Token已过期，需要重新登录")
                return False, "登录已过期，请重新登录", None

            # 3. 验证Token有效性（可选，减少服务器压力）
            # 这里可以添加Token验证逻辑

            return True, "认证有效", self.current_user

        except Exception as e:
            print(f"[认证] 认证检查异常: {e}")
            return False, f"认证检查失败: {str(e)}", None

    def logout(self):
        """登出"""
        try:
            # 清除本地状态
            self.current_user = None
            self.session_token = None
            self.token_expires_at = 0

            # 清除本地缓存
            self._clear_user_cache()

            print("[登出] 用户已登出")

        except Exception as e:
            print(f"[登出] 登出异常: {e}")

    def _call_api(self, endpoint: str, data: Dict, method: str = "GET") -> Dict:
        """调用API"""
        url = f"{self.api_base_url}{endpoint}"
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "PyQt5 Client v2.0"
        }

        # 添加认证头
        if self.session_token:
            headers["Authorization"] = f"Bearer {self.session_token}"

        try:
            if method == "POST":
                response = requests.post(url, json=data, headers=headers, timeout=10)
            else:
                response = requests.get(url, params=data, headers=headers, timeout=10)

            response.raise_for_status()
            return response.json()

        except requests.exceptions.RequestException as e:
            print(f"API调用失败: {e}")
            raise

    def _validate_phone(self, phone: str) -> bool:
        """验证手机号格式"""
        import re
        pattern = r'^1[3-9]\d{9}$'
        return re.match(pattern, phone) is not None

    def _get_local_ip(self) -> str:
        """获取本地IP地址"""
        try:
            import socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "Unknown"

    def _save_user_cache(self, user_info: Dict):
        """保存用户缓存"""
        try:
            cache_data = {
                "user_info": user_info,
                "session_token": self.session_token,
                "token_expires_at": self.token_expires_at,
                "cached_at": int(time.time())
            }

            with open("user_cache.json", "w", encoding="utf-8") as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)

        except Exception as e:
            print(f"保存用户缓存失败: {e}")

    def _clear_user_cache(self):
        """清除用户缓存"""
        try:
            import os
            if os.path.exists("user_cache.json"):
                os.remove("user_cache.json")
        except Exception as e:
            print(f"清除用户缓存失败: {e}")

# 全局实例
enhanced_auth_service = EnhancedAuthService()
```
```