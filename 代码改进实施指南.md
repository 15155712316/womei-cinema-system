# 代码改进实施指南

## 🎯 立即可实施的改进方案

基于代码质量分析报告，以下是可以立即开始实施的具体改进方案。

---

## 🔴 第一优先级：统一异常处理装饰器

### 创建异常处理装饰器

```python
# utils/exception_handler.py
import functools
import logging
from typing import Any, Callable, Dict

logger = logging.getLogger(__name__)

def api_exception_handler(default_return: Any = None):
    """API异常处理装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except requests.exceptions.ConnectionError:
                logger.error(f"{func.__name__}: 网络连接失败")
                return {"resultCode": "-1", "resultDesc": "网络连接失败"}
            except requests.exceptions.Timeout:
                logger.error(f"{func.__name__}: 请求超时")
                return {"resultCode": "-1", "resultDesc": "请求超时"}
            except ValueError as e:
                logger.error(f"{func.__name__}: 参数错误 - {e}")
                return {"resultCode": "-1", "resultDesc": f"参数错误: {e}"}
            except Exception as e:
                logger.error(f"{func.__name__}: 未知错误 - {e}")
                return default_return or {"resultCode": "-1", "resultDesc": "系统错误"}
        return wrapper
    return decorator

def ui_exception_handler(show_message: bool = True):
    """UI异常处理装饰器"""
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(self, *args, **kwargs):
            try:
                return func(self, *args, **kwargs)
            except Exception as e:
                logger.error(f"{func.__name__}: UI错误 - {e}")
                if show_message and hasattr(self, 'show_error_message'):
                    self.show_error_message(f"操作失败: {str(e)}")
                return None
        return wrapper
    return decorator
```

### 应用到现有代码

```python
# services/order_api.py 中的应用示例
from utils.exception_handler import api_exception_handler

class OrderAPI:
    @api_exception_handler()
    def create_order(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """创建订单"""
        return self._make_request('POST', 'createOrder', json=params)
    
    @api_exception_handler()
    def get_order_detail(self, order_no: str) -> Dict[str, Any]:
        """获取订单详情"""
        return self._make_request('GET', f'orderDetail/{order_no}')
```

---

## 🔴 第二优先级：建立标准日志系统

### 创建日志配置

```python
# utils/logger_setup.py
import logging
import logging.handlers
import os
from datetime import datetime

class LoggerSetup:
    @staticmethod
    def setup_logger(name: str, level: int = logging.INFO) -> logging.Logger:
        """设置标准日志器"""
        logger = logging.getLogger(name)
        
        # 避免重复添加处理器
        if logger.handlers:
            return logger
            
        logger.setLevel(level)
        
        # 确保日志目录存在
        log_dir = "logs"
        os.makedirs(log_dir, exist_ok=True)
        
        # 文件处理器 - 按日期轮转
        log_file = os.path.join(log_dir, f"{name}_{datetime.now().strftime('%Y%m%d')}.log")
        file_handler = logging.handlers.RotatingFileHandler(
            log_file, 
            maxBytes=10*1024*1024,  # 10MB
            backupCount=5,
            encoding='utf-8'
        )
        
        # 控制台处理器
        console_handler = logging.StreamHandler()
        
        # 格式化器
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
        )
        
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger

# 全局日志器实例
api_logger = LoggerSetup.setup_logger('api')
ui_logger = LoggerSetup.setup_logger('ui')
system_logger = LoggerSetup.setup_logger('system')
```

### 替换现有的print语句

```python
# 替换前
print(f"[二维码生成] ✅ 策略1-直接导入: 成功")

# 替换后
from utils.logger_setup import system_logger
system_logger.info("二维码生成: 策略1-直接导入成功")
```

---

## 🔴 第三优先级：简化二维码生成器

### 重构二维码生成器

```python
# utils/qrcode_manager.py
import logging
from typing import Optional, Tuple, Any
from PIL import Image

logger = logging.getLogger(__name__)

class QRCodeManager:
    """二维码管理器 - 单例模式"""
    _instance = None
    _qrcode_module = None
    _is_available = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if self._is_available is None:
            self._check_availability()
    
    def _check_availability(self) -> None:
        """检查qrcode模块可用性"""
        try:
            import qrcode
            self._qrcode_module = qrcode
            self._is_available = True
            logger.info("qrcode模块加载成功")
        except ImportError:
            self._qrcode_module = None
            self._is_available = False
            logger.warning("qrcode模块不可用，将使用备用方案")
    
    def is_available(self) -> bool:
        """检查是否可用"""
        return self._is_available
    
    def generate_qrcode(self, data: str, size: Tuple[int, int] = (200, 200)) -> Optional[Image.Image]:
        """生成二维码"""
        if self._is_available and self._qrcode_module:
            return self._generate_with_qrcode(data, size)
        else:
            return self._generate_fallback(data, size)
    
    def _generate_with_qrcode(self, data: str, size: Tuple[int, int]) -> Image.Image:
        """使用qrcode库生成"""
        qr = self._qrcode_module.QRCode(
            version=1,
            error_correction=self._qrcode_module.constants.ERROR_CORRECT_M,
            box_size=10,
            border=4,
        )
        qr.add_data(data)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        return img.resize(size, Image.NEAREST)
    
    def _generate_fallback(self, data: str, size: Tuple[int, int]) -> Image.Image:
        """备用方案：生成包含文本的图片"""
        from PIL import ImageDraw, ImageFont
        
        img = Image.new('RGB', size, 'white')
        draw = ImageDraw.Draw(img)
        
        try:
            font = ImageFont.truetype("arial.ttf", 16)
        except:
            font = ImageFont.load_default()
        
        # 居中绘制文本
        text_bbox = draw.textbbox((0, 0), data, font=font)
        text_width = text_bbox[2] - text_bbox[0]
        text_height = text_bbox[3] - text_bbox[1]
        
        x = (size[0] - text_width) // 2
        y = (size[1] - text_height) // 2
        
        draw.text((x, y), data, fill='black', font=font)
        return img

# 全局实例
qr_manager = QRCodeManager()
```

---

## 🔴 第四优先级：创建API基类

### 统一API基类

```python
# services/base_api.py
import requests
import logging
from typing import Dict, Any, Optional
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)

class BaseAPI(ABC):
    """API基类"""
    
    def __init__(self, base_url: str, timeout: int = 10):
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        self._setup_session()
    
    def _setup_session(self) -> None:
        """设置会话"""
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'CinemaTicketSystem/1.0'
        })
    
    def _make_request(self, method: str, endpoint: str, **kwargs) -> Dict[str, Any]:
        """统一请求处理"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            response = self.session.request(
                method=method,
                url=url,
                timeout=self.timeout,
                **kwargs
            )
            
            return self._handle_response(response)
            
        except requests.exceptions.ConnectionError:
            logger.error(f"连接失败: {url}")
            return self._error_response("网络连接失败")
        except requests.exceptions.Timeout:
            logger.error(f"请求超时: {url}")
            return self._error_response("请求超时")
        except Exception as e:
            logger.error(f"请求异常: {url} - {e}")
            return self._error_response("请求异常")
    
    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:
        """处理响应"""
        if response.status_code == 200:
            try:
                return response.json()
            except ValueError:
                return self._error_response("响应格式错误")
        else:
            logger.error(f"HTTP错误: {response.status_code}")
            return self._error_response(f"HTTP错误: {response.status_code}")
    
    def _error_response(self, message: str) -> Dict[str, Any]:
        """标准错误响应"""
        return {
            "resultCode": "-1",
            "resultDesc": message,
            "success": False
        }
    
    def _success_response(self, data: Any = None) -> Dict[str, Any]:
        """标准成功响应"""
        return {
            "resultCode": "0",
            "resultDesc": "成功",
            "success": True,
            "data": data
        }
    
    @abstractmethod
    def get_api_name(self) -> str:
        """获取API名称"""
        pass
```

### 重构现有API类

```python
# services/order_api.py
from .base_api import BaseAPI
from typing import Dict, Any

class OrderAPI(BaseAPI):
    """订单API"""
    
    def get_api_name(self) -> str:
        return "OrderAPI"
    
    def create_order(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """创建订单"""
        return self._make_request('POST', 'createOrder', json=params)
    
    def get_order_detail(self, order_no: str) -> Dict[str, Any]:
        """获取订单详情"""
        return self._make_request('GET', f'orderDetail/{order_no}')
    
    def cancel_order(self, order_no: str) -> Dict[str, Any]:
        """取消订单"""
        return self._make_request('POST', 'cancelOrder', json={'orderNo': order_no})
```

---

## 🟡 第五优先级：类型注解完善

### 添加类型注解示例

```python
# 改进前
def create_order(self, params):
    return self.api_post('createOrder', params)

# 改进后
from typing import Dict, Any, Optional

def create_order(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """
    创建订单
    
    Args:
        params: 订单参数字典，包含座位信息、场次信息等
        
    Returns:
        API响应结果字典，包含resultCode、resultDesc等字段
        
    Raises:
        ValueError: 参数验证失败时抛出
        ConnectionError: 网络连接失败时抛出
    """
    if not params or not isinstance(params, dict):
        raise ValueError("订单参数不能为空且必须是字典类型")
    
    return self._make_request('POST', 'createOrder', json=params)
```

---

## 📋 实施检查清单

### 第一周任务清单
- [ ] 创建 `utils/exception_handler.py`
- [ ] 创建 `utils/logger_setup.py`
- [ ] 创建 `utils/qrcode_manager.py`
- [ ] 创建 `services/base_api.py`
- [ ] 重构 `services/order_api.py` 继承BaseAPI
- [ ] 替换主要模块中的print语句为日志
- [ ] 应用异常处理装饰器到关键函数

### 验证步骤
1. **异常处理验证**：故意触发网络错误，检查是否正确处理
2. **日志系统验证**：检查logs目录是否生成日志文件
3. **二维码验证**：测试在有/无qrcode库情况下的生成
4. **API统一性验证**：检查所有API返回格式是否一致

### 性能指标
- **代码重复减少**：目标减少60%
- **异常处理覆盖率**：目标达到90%
- **日志记录完整性**：目标覆盖所有关键操作
- **API响应一致性**：目标100%统一格式

---

## 🎯 预期效果

实施这些改进后，预期达到以下效果：

1. **代码质量提升**：从6.2分提升到7.5分
2. **维护效率提升**：问题定位时间减少70%
3. **开发效率提升**：新功能开发速度提升40%
4. **系统稳定性提升**：异常处理覆盖率达到90%
5. **用户体验提升**：错误提示更加友好和准确

---

*实施指南创建时间：2024年12月*  
*建议实施周期：1-2周*
