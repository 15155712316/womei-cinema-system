# PyQt5电影票务管理系统 - 安全机制设计

## 📋 **安全方案概览**

**目标**：确保50-100用户的设备唯一绑定和系统安全  
**核心机制**：多层安全防护 + 异常检测 + 审计日志  
**防护重点**：设备绑定安全、防刷机制、异常检测、权限控制

---

## 🔒 **6. 安全机制设计**

### **6.1 设备绑定安全机制**

#### **多重设备标识验证**
```python
# security/device_security.py
import hashlib
import time
from typing import Dict, List, Tuple

class DeviceSecurityManager:
    """设备安全管理器"""
    
    def __init__(self, db):
        self.users = db["users"]
        self.security_logs = db["securityLogs"]
        self.device_fingerprints = db["deviceFingerprints"]
    
    def generate_device_fingerprint(self, device_info: Dict) -> str:
        """生成设备指纹"""
        # 收集多个硬件标识符
        identifiers = [
            device_info.get("machineCode", ""),
            device_info.get("cpuId", ""),
            device_info.get("diskSerial", ""),
            device_info.get("motherboardSerial", ""),
            device_info.get("macAddress", ""),
            device_info.get("biosSerial", "")
        ]
        
        # 过滤空值并排序（确保一致性）
        valid_identifiers = sorted([id for id in identifiers if id])
        
        # 生成复合指纹
        combined = "|".join(valid_identifiers)
        fingerprint = hashlib.sha256(combined.encode()).hexdigest()
        
        return fingerprint
    
    def verify_device_binding(self, phone: str, device_info: Dict) -> Dict:
        """验证设备绑定"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"success": False, "reason": "user_not_found"}
            
            # 生成当前设备指纹
            current_fingerprint = self.generate_device_fingerprint(device_info)
            
            # 获取用户绑定的设备指纹
            bound_fingerprint = user.get("device", {}).get("fingerprint")
            
            if not bound_fingerprint:
                # 首次绑定
                return self._bind_new_device(phone, device_info, current_fingerprint)
            elif bound_fingerprint == current_fingerprint:
                # 设备匹配
                return {"success": True, "reason": "device_matched"}
            else:
                # 设备不匹配，进行深度验证
                return self._deep_device_verification(phone, device_info, current_fingerprint, bound_fingerprint)
                
        except Exception as e:
            self._log_security_event("device_verification_error", phone, {"error": str(e)})
            return {"success": False, "reason": "verification_error"}
    
    def _bind_new_device(self, phone: str, device_info: Dict, fingerprint: str) -> Dict:
        """绑定新设备"""
        try:
            # 更新用户设备信息
            self.users.update_one(
                {"phone": phone},
                {
                    "$set": {
                        "device.fingerprint": fingerprint,
                        "device.machineCode": device_info.get("machineCode"),
                        "device.deviceInfo": device_info,
                        "device.bindTime": datetime.now(),
                        "device.bindMethod": "auto",
                        "metadata.updatedAt": datetime.now()
                    }
                }
            )
            
            # 保存设备指纹记录
            self.device_fingerprints.insert_one({
                "phone": phone,
                "fingerprint": fingerprint,
                "deviceInfo": device_info,
                "bindTime": datetime.now(),
                "status": "active"
            })
            
            self._log_security_event("device_bound", phone, {"fingerprint": fingerprint})
            return {"success": True, "reason": "device_bound"}
            
        except Exception as e:
            self._log_security_event("device_bind_error", phone, {"error": str(e)})
            return {"success": False, "reason": "bind_error"}
    
    def _deep_device_verification(self, phone: str, device_info: Dict, current_fp: str, bound_fp: str) -> Dict:
        """深度设备验证"""
        try:
            # 计算设备指纹相似度
            similarity = self._calculate_fingerprint_similarity(current_fp, bound_fp)
            
            # 检查是否为硬件升级（部分硬件变更）
            if similarity > 0.7:  # 70%相似度阈值
                # 可能是硬件升级，记录并允许
                self._log_security_event("device_hardware_change", phone, {
                    "oldFingerprint": bound_fp,
                    "newFingerprint": current_fp,
                    "similarity": similarity
                })
                
                # 更新设备指纹
                self.users.update_one(
                    {"phone": phone},
                    {
                        "$set": {
                            "device.fingerprint": current_fp,
                            "device.lastHardwareChange": datetime.now(),
                            "device.hardwareChangeReason": "auto_detected"
                        }
                    }
                )
                
                return {"success": True, "reason": "hardware_upgraded"}
            else:
                # 设备完全不匹配
                self._log_security_event("device_mismatch", phone, {
                    "expectedFingerprint": bound_fp,
                    "actualFingerprint": current_fp,
                    "similarity": similarity
                })
                
                return {"success": False, "reason": "device_unauthorized"}
                
        except Exception as e:
            self._log_security_event("deep_verification_error", phone, {"error": str(e)})
            return {"success": False, "reason": "verification_error"}
    
    def _calculate_fingerprint_similarity(self, fp1: str, fp2: str) -> float:
        """计算指纹相似度"""
        if len(fp1) != len(fp2):
            return 0.0
        
        matches = sum(c1 == c2 for c1, c2 in zip(fp1, fp2))
        return matches / len(fp1)
    
    def _log_security_event(self, event_type: str, phone: str, details: Dict):
        """记录安全事件"""
        try:
            log_entry = {
                "eventType": event_type,
                "phone": phone,
                "details": details,
                "timestamp": datetime.now(),
                "ip": request.environ.get('REMOTE_ADDR', 'Unknown') if 'request' in globals() else 'Unknown'
            }
            self.security_logs.insert_one(log_entry)
        except Exception as e:
            print(f"记录安全日志失败: {e}")

# 全局安全管理器
device_security = DeviceSecurityManager(auth_api.db)
```

### **6.2 防刷和异常检测机制**

#### **登录频率限制**
```python
class AntiAbuseManager:
    """防刷管理器"""
    
    def __init__(self, db):
        self.users = db["users"]
        self.login_logs = db["loginLogs"]
        self.abuse_logs = db["abuseLogs"]
        
        # 配置参数
        self.max_login_attempts = 5  # 最大登录尝试次数
        self.lockout_duration = 300  # 锁定时长（秒）
        self.rate_limit_window = 60  # 频率限制窗口（秒）
        self.max_requests_per_window = 10  # 窗口内最大请求数
    
    def check_login_rate_limit(self, phone: str, ip: str) -> Dict:
        """检查登录频率限制"""
        try:
            now = datetime.now()
            window_start = now - timedelta(seconds=self.rate_limit_window)
            
            # 检查手机号频率
            phone_attempts = self.login_logs.count_documents({
                "phone": phone,
                "loginTime": {"$gte": window_start}
            })
            
            # 检查IP频率
            ip_attempts = self.login_logs.count_documents({
                "deviceInfo.ip": ip,
                "loginTime": {"$gte": window_start}
            })
            
            if phone_attempts >= self.max_requests_per_window:
                self._log_abuse_event("phone_rate_limit", phone, {"attempts": phone_attempts, "ip": ip})
                return {"allowed": False, "reason": "phone_rate_limit", "wait_time": self.rate_limit_window}
            
            if ip_attempts >= self.max_requests_per_window * 3:  # IP限制更宽松
                self._log_abuse_event("ip_rate_limit", ip, {"attempts": ip_attempts})
                return {"allowed": False, "reason": "ip_rate_limit", "wait_time": self.rate_limit_window}
            
            return {"allowed": True}
            
        except Exception as e:
            print(f"检查频率限制失败: {e}")
            return {"allowed": True}  # 出错时允许通过
    
    def check_account_lockout(self, phone: str) -> Dict:
        """检查账号锁定状态"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"locked": False}
            
            security = user.get("security", {})
            lock_until = security.get("lockUntil")
            
            if lock_until and datetime.now() < lock_until:
                remaining = int((lock_until - datetime.now()).total_seconds())
                return {"locked": True, "remaining": remaining}
            
            return {"locked": False}
            
        except Exception as e:
            print(f"检查账号锁定失败: {e}")
            return {"locked": False}
    
    def record_login_attempt(self, phone: str, success: bool, ip: str, reason: str = None):
        """记录登录尝试"""
        try:
            if not success:
                # 增加失败次数
                user = self.users.find_one({"phone": phone})
                if user:
                    current_attempts = user.get("security", {}).get("loginAttempts", 0)
                    new_attempts = current_attempts + 1
                    
                    update_data = {
                        "security.loginAttempts": new_attempts,
                        "security.lastFailedLogin": datetime.now()
                    }
                    
                    # 检查是否需要锁定账号
                    if new_attempts >= self.max_login_attempts:
                        lock_until = datetime.now() + timedelta(seconds=self.lockout_duration)
                        update_data["security.lockUntil"] = lock_until
                        
                        self._log_abuse_event("account_locked", phone, {
                            "attempts": new_attempts,
                            "lockUntil": lock_until.isoformat(),
                            "ip": ip
                        })
                    
                    self.users.update_one({"phone": phone}, {"$set": update_data})
            else:
                # 登录成功，重置失败次数
                self.users.update_one(
                    {"phone": phone},
                    {
                        "$unset": {"security.loginAttempts": "", "security.lockUntil": ""},
                        "$set": {"security.lastSuccessLogin": datetime.now()}
                    }
                )
                
        except Exception as e:
            print(f"记录登录尝试失败: {e}")
    
    def detect_suspicious_activity(self, phone: str, device_info: Dict) -> List[str]:
        """检测可疑活动"""
        suspicious_indicators = []
        
        try:
            # 检查设备信息异常
            if not device_info.get("machineCode"):
                suspicious_indicators.append("missing_machine_code")
            
            if not device_info.get("os") or device_info.get("os") == "Unknown":
                suspicious_indicators.append("unknown_os")
            
            # 检查登录时间模式
            recent_logins = list(self.login_logs.find({
                "phone": phone,
                "loginTime": {"$gte": datetime.now() - timedelta(days=7)},
                "loginResult": "success"
            }).sort("loginTime", -1).limit(10))
            
            if len(recent_logins) > 0:
                # 检查登录时间间隔异常
                time_intervals = []
                for i in range(1, len(recent_logins)):
                    interval = (recent_logins[i-1]["loginTime"] - recent_logins[i]["loginTime"]).total_seconds()
                    time_intervals.append(interval)
                
                if time_intervals:
                    avg_interval = sum(time_intervals) / len(time_intervals)
                    if avg_interval < 300:  # 平均间隔小于5分钟
                        suspicious_indicators.append("frequent_login")
            
            # 检查多设备登录
            unique_machines = set()
            for login in recent_logins:
                machine_code = login.get("machineCode")
                if machine_code:
                    unique_machines.add(machine_code)
            
            if len(unique_machines) > 1:
                suspicious_indicators.append("multiple_devices")
            
            # 记录可疑活动
            if suspicious_indicators:
                self._log_abuse_event("suspicious_activity", phone, {
                    "indicators": suspicious_indicators,
                    "deviceInfo": device_info
                })
            
            return suspicious_indicators
            
        except Exception as e:
            print(f"检测可疑活动失败: {e}")
            return []
    
    def _log_abuse_event(self, event_type: str, target: str, details: Dict):
        """记录滥用事件"""
        try:
            log_entry = {
                "eventType": event_type,
                "target": target,
                "details": details,
                "timestamp": datetime.now(),
                "severity": self._get_event_severity(event_type)
            }
            self.abuse_logs.insert_one(log_entry)
        except Exception as e:
            print(f"记录滥用日志失败: {e}")
    
    def _get_event_severity(self, event_type: str) -> str:
        """获取事件严重程度"""
        severity_map = {
            "phone_rate_limit": "medium",
            "ip_rate_limit": "medium",
            "account_locked": "high",
            "suspicious_activity": "medium",
            "multiple_devices": "high"
        }
        return severity_map.get(event_type, "low")

# 全局防刷管理器
anti_abuse = AntiAbuseManager(auth_api.db)
```

### **6.3 权限控制系统**

#### **基于角色的权限管理**
```python
class PermissionManager:
    """权限管理器"""
    
    def __init__(self, db):
        self.users = db["users"]
        self.roles = db["roles"]
        self.permissions = db["permissions"]
        
        # 初始化默认角色和权限
        self._init_default_roles()
    
    def _init_default_roles(self):
        """初始化默认角色"""
        default_roles = [
            {
                "roleId": "basic_user",
                "name": "基础用户",
                "description": "普通用户权限",
                "permissions": ["login", "view_movies", "create_order", "view_order_history"],
                "isDefault": True
            },
            {
                "roleId": "vip_user",
                "name": "VIP用户",
                "description": "VIP用户权限",
                "permissions": ["login", "view_movies", "create_order", "view_order_history", "priority_booking", "discount_access"],
                "isDefault": False
            },
            {
                "roleId": "admin",
                "name": "管理员",
                "description": "系统管理员",
                "permissions": ["*"],  # 所有权限
                "isDefault": False
            }
        ]
        
        for role in default_roles:
            self.roles.update_one(
                {"roleId": role["roleId"]},
                {"$set": role},
                upsert=True
            )
    
    def check_permission(self, phone: str, permission: str) -> bool:
        """检查用户权限"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return False
            
            # 检查账号状态
            if user.get("account", {}).get("status", {}).get("code", 1) != 1:
                return False
            
            # 获取用户权限
            user_permissions = user.get("account", {}).get("permissions", [])
            
            # 检查是否有通配符权限
            if "*" in user_permissions:
                return True
            
            # 检查具体权限
            return permission in user_permissions
            
        except Exception as e:
            print(f"检查权限失败: {e}")
            return False
    
    def assign_role(self, phone: str, role_id: str) -> Dict:
        """分配角色"""
        try:
            # 获取角色信息
            role = self.roles.find_one({"roleId": role_id})
            if not role:
                return {"success": False, "message": "角色不存在"}
            
            # 更新用户权限
            result = self.users.update_one(
                {"phone": phone},
                {
                    "$set": {
                        "account.role": role_id,
                        "account.permissions": role["permissions"],
                        "metadata.updatedAt": datetime.now()
                    }
                }
            )
            
            if result.modified_count > 0:
                return {"success": True, "message": "角色分配成功"}
            else:
                return {"success": False, "message": "用户不存在"}
                
        except Exception as e:
            return {"success": False, "message": f"分配失败: {str(e)}"}

# 全局权限管理器
permission_manager = PermissionManager(auth_api.db)
```
