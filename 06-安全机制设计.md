# PyQt5ç”µå½±ç¥¨åŠ¡ç®¡ç†ç³»ç»Ÿ - å®‰å…¨æœºåˆ¶è®¾è®¡

## ğŸ“‹ **å®‰å…¨æ–¹æ¡ˆæ¦‚è§ˆ**

**ç›®æ ‡**ï¼šç¡®ä¿50-100ç”¨æˆ·çš„è®¾å¤‡å”¯ä¸€ç»‘å®šå’Œç³»ç»Ÿå®‰å…¨  
**æ ¸å¿ƒæœºåˆ¶**ï¼šå¤šå±‚å®‰å…¨é˜²æŠ¤ + å¼‚å¸¸æ£€æµ‹ + å®¡è®¡æ—¥å¿—  
**é˜²æŠ¤é‡ç‚¹**ï¼šè®¾å¤‡ç»‘å®šå®‰å…¨ã€é˜²åˆ·æœºåˆ¶ã€å¼‚å¸¸æ£€æµ‹ã€æƒé™æ§åˆ¶

---

## ğŸ”’ **6. å®‰å…¨æœºåˆ¶è®¾è®¡**

### **6.1 è®¾å¤‡ç»‘å®šå®‰å…¨æœºåˆ¶**

#### **å¤šé‡è®¾å¤‡æ ‡è¯†éªŒè¯**
```python
# security/device_security.py
import hashlib
import time
from typing import Dict, List, Tuple

class DeviceSecurityManager:
    """è®¾å¤‡å®‰å…¨ç®¡ç†å™¨"""
    
    def __init__(self, db):
        self.users = db["users"]
        self.security_logs = db["securityLogs"]
        self.device_fingerprints = db["deviceFingerprints"]
    
    def generate_device_fingerprint(self, device_info: Dict) -> str:
        """ç”Ÿæˆè®¾å¤‡æŒ‡çº¹"""
        # æ”¶é›†å¤šä¸ªç¡¬ä»¶æ ‡è¯†ç¬¦
        identifiers = [
            device_info.get("machineCode", ""),
            device_info.get("cpuId", ""),
            device_info.get("diskSerial", ""),
            device_info.get("motherboardSerial", ""),
            device_info.get("macAddress", ""),
            device_info.get("biosSerial", "")
        ]
        
        # è¿‡æ»¤ç©ºå€¼å¹¶æ’åºï¼ˆç¡®ä¿ä¸€è‡´æ€§ï¼‰
        valid_identifiers = sorted([id for id in identifiers if id])
        
        # ç”Ÿæˆå¤åˆæŒ‡çº¹
        combined = "|".join(valid_identifiers)
        fingerprint = hashlib.sha256(combined.encode()).hexdigest()
        
        return fingerprint
    
    def verify_device_binding(self, phone: str, device_info: Dict) -> Dict:
        """éªŒè¯è®¾å¤‡ç»‘å®š"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"success": False, "reason": "user_not_found"}
            
            # ç”Ÿæˆå½“å‰è®¾å¤‡æŒ‡çº¹
            current_fingerprint = self.generate_device_fingerprint(device_info)
            
            # è·å–ç”¨æˆ·ç»‘å®šçš„è®¾å¤‡æŒ‡çº¹
            bound_fingerprint = user.get("device", {}).get("fingerprint")
            
            if not bound_fingerprint:
                # é¦–æ¬¡ç»‘å®š
                return self._bind_new_device(phone, device_info, current_fingerprint)
            elif bound_fingerprint == current_fingerprint:
                # è®¾å¤‡åŒ¹é…
                return {"success": True, "reason": "device_matched"}
            else:
                # è®¾å¤‡ä¸åŒ¹é…ï¼Œè¿›è¡Œæ·±åº¦éªŒè¯
                return self._deep_device_verification(phone, device_info, current_fingerprint, bound_fingerprint)
                
        except Exception as e:
            self._log_security_event("device_verification_error", phone, {"error": str(e)})
            return {"success": False, "reason": "verification_error"}
    
    def _bind_new_device(self, phone: str, device_info: Dict, fingerprint: str) -> Dict:
        """ç»‘å®šæ–°è®¾å¤‡"""
        try:
            # æ›´æ–°ç”¨æˆ·è®¾å¤‡ä¿¡æ¯
            self.users.update_one(
                {"phone": phone},
                {
                    "$set": {
                        "device.fingerprint": fingerprint,
                        "device.machineCode": device_info.get("machineCode"),
                        "device.deviceInfo": device_info,
                        "device.bindTime": datetime.now(),
                        "device.bindMethod": "auto",
                        "metadata.updatedAt": datetime.now()
                    }
                }
            )
            
            # ä¿å­˜è®¾å¤‡æŒ‡çº¹è®°å½•
            self.device_fingerprints.insert_one({
                "phone": phone,
                "fingerprint": fingerprint,
                "deviceInfo": device_info,
                "bindTime": datetime.now(),
                "status": "active"
            })
            
            self._log_security_event("device_bound", phone, {"fingerprint": fingerprint})
            return {"success": True, "reason": "device_bound"}
            
        except Exception as e:
            self._log_security_event("device_bind_error", phone, {"error": str(e)})
            return {"success": False, "reason": "bind_error"}
    
    def _deep_device_verification(self, phone: str, device_info: Dict, current_fp: str, bound_fp: str) -> Dict:
        """æ·±åº¦è®¾å¤‡éªŒè¯"""
        try:
            # è®¡ç®—è®¾å¤‡æŒ‡çº¹ç›¸ä¼¼åº¦
            similarity = self._calculate_fingerprint_similarity(current_fp, bound_fp)
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç¡¬ä»¶å‡çº§ï¼ˆéƒ¨åˆ†ç¡¬ä»¶å˜æ›´ï¼‰
            if similarity > 0.7:  # 70%ç›¸ä¼¼åº¦é˜ˆå€¼
                # å¯èƒ½æ˜¯ç¡¬ä»¶å‡çº§ï¼Œè®°å½•å¹¶å…è®¸
                self._log_security_event("device_hardware_change", phone, {
                    "oldFingerprint": bound_fp,
                    "newFingerprint": current_fp,
                    "similarity": similarity
                })
                
                # æ›´æ–°è®¾å¤‡æŒ‡çº¹
                self.users.update_one(
                    {"phone": phone},
                    {
                        "$set": {
                            "device.fingerprint": current_fp,
                            "device.lastHardwareChange": datetime.now(),
                            "device.hardwareChangeReason": "auto_detected"
                        }
                    }
                )
                
                return {"success": True, "reason": "hardware_upgraded"}
            else:
                # è®¾å¤‡å®Œå…¨ä¸åŒ¹é…
                self._log_security_event("device_mismatch", phone, {
                    "expectedFingerprint": bound_fp,
                    "actualFingerprint": current_fp,
                    "similarity": similarity
                })
                
                return {"success": False, "reason": "device_unauthorized"}
                
        except Exception as e:
            self._log_security_event("deep_verification_error", phone, {"error": str(e)})
            return {"success": False, "reason": "verification_error"}
    
    def _calculate_fingerprint_similarity(self, fp1: str, fp2: str) -> float:
        """è®¡ç®—æŒ‡çº¹ç›¸ä¼¼åº¦"""
        if len(fp1) != len(fp2):
            return 0.0
        
        matches = sum(c1 == c2 for c1, c2 in zip(fp1, fp2))
        return matches / len(fp1)
    
    def _log_security_event(self, event_type: str, phone: str, details: Dict):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        try:
            log_entry = {
                "eventType": event_type,
                "phone": phone,
                "details": details,
                "timestamp": datetime.now(),
                "ip": request.environ.get('REMOTE_ADDR', 'Unknown') if 'request' in globals() else 'Unknown'
            }
            self.security_logs.insert_one(log_entry)
        except Exception as e:
            print(f"è®°å½•å®‰å…¨æ—¥å¿—å¤±è´¥: {e}")

# å…¨å±€å®‰å…¨ç®¡ç†å™¨
device_security = DeviceSecurityManager(auth_api.db)
```

### **6.2 é˜²åˆ·å’Œå¼‚å¸¸æ£€æµ‹æœºåˆ¶**

#### **ç™»å½•é¢‘ç‡é™åˆ¶**
```python
class AntiAbuseManager:
    """é˜²åˆ·ç®¡ç†å™¨"""
    
    def __init__(self, db):
        self.users = db["users"]
        self.login_logs = db["loginLogs"]
        self.abuse_logs = db["abuseLogs"]
        
        # é…ç½®å‚æ•°
        self.max_login_attempts = 5  # æœ€å¤§ç™»å½•å°è¯•æ¬¡æ•°
        self.lockout_duration = 300  # é”å®šæ—¶é•¿ï¼ˆç§’ï¼‰
        self.rate_limit_window = 60  # é¢‘ç‡é™åˆ¶çª—å£ï¼ˆç§’ï¼‰
        self.max_requests_per_window = 10  # çª—å£å†…æœ€å¤§è¯·æ±‚æ•°
    
    def check_login_rate_limit(self, phone: str, ip: str) -> Dict:
        """æ£€æŸ¥ç™»å½•é¢‘ç‡é™åˆ¶"""
        try:
            now = datetime.now()
            window_start = now - timedelta(seconds=self.rate_limit_window)
            
            # æ£€æŸ¥æ‰‹æœºå·é¢‘ç‡
            phone_attempts = self.login_logs.count_documents({
                "phone": phone,
                "loginTime": {"$gte": window_start}
            })
            
            # æ£€æŸ¥IPé¢‘ç‡
            ip_attempts = self.login_logs.count_documents({
                "deviceInfo.ip": ip,
                "loginTime": {"$gte": window_start}
            })
            
            if phone_attempts >= self.max_requests_per_window:
                self._log_abuse_event("phone_rate_limit", phone, {"attempts": phone_attempts, "ip": ip})
                return {"allowed": False, "reason": "phone_rate_limit", "wait_time": self.rate_limit_window}
            
            if ip_attempts >= self.max_requests_per_window * 3:  # IPé™åˆ¶æ›´å®½æ¾
                self._log_abuse_event("ip_rate_limit", ip, {"attempts": ip_attempts})
                return {"allowed": False, "reason": "ip_rate_limit", "wait_time": self.rate_limit_window}
            
            return {"allowed": True}
            
        except Exception as e:
            print(f"æ£€æŸ¥é¢‘ç‡é™åˆ¶å¤±è´¥: {e}")
            return {"allowed": True}  # å‡ºé”™æ—¶å…è®¸é€šè¿‡
    
    def check_account_lockout(self, phone: str) -> Dict:
        """æ£€æŸ¥è´¦å·é”å®šçŠ¶æ€"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return {"locked": False}
            
            security = user.get("security", {})
            lock_until = security.get("lockUntil")
            
            if lock_until and datetime.now() < lock_until:
                remaining = int((lock_until - datetime.now()).total_seconds())
                return {"locked": True, "remaining": remaining}
            
            return {"locked": False}
            
        except Exception as e:
            print(f"æ£€æŸ¥è´¦å·é”å®šå¤±è´¥: {e}")
            return {"locked": False}
    
    def record_login_attempt(self, phone: str, success: bool, ip: str, reason: str = None):
        """è®°å½•ç™»å½•å°è¯•"""
        try:
            if not success:
                # å¢åŠ å¤±è´¥æ¬¡æ•°
                user = self.users.find_one({"phone": phone})
                if user:
                    current_attempts = user.get("security", {}).get("loginAttempts", 0)
                    new_attempts = current_attempts + 1
                    
                    update_data = {
                        "security.loginAttempts": new_attempts,
                        "security.lastFailedLogin": datetime.now()
                    }
                    
                    # æ£€æŸ¥æ˜¯å¦éœ€è¦é”å®šè´¦å·
                    if new_attempts >= self.max_login_attempts:
                        lock_until = datetime.now() + timedelta(seconds=self.lockout_duration)
                        update_data["security.lockUntil"] = lock_until
                        
                        self._log_abuse_event("account_locked", phone, {
                            "attempts": new_attempts,
                            "lockUntil": lock_until.isoformat(),
                            "ip": ip
                        })
                    
                    self.users.update_one({"phone": phone}, {"$set": update_data})
            else:
                # ç™»å½•æˆåŠŸï¼Œé‡ç½®å¤±è´¥æ¬¡æ•°
                self.users.update_one(
                    {"phone": phone},
                    {
                        "$unset": {"security.loginAttempts": "", "security.lockUntil": ""},
                        "$set": {"security.lastSuccessLogin": datetime.now()}
                    }
                )
                
        except Exception as e:
            print(f"è®°å½•ç™»å½•å°è¯•å¤±è´¥: {e}")
    
    def detect_suspicious_activity(self, phone: str, device_info: Dict) -> List[str]:
        """æ£€æµ‹å¯ç–‘æ´»åŠ¨"""
        suspicious_indicators = []
        
        try:
            # æ£€æŸ¥è®¾å¤‡ä¿¡æ¯å¼‚å¸¸
            if not device_info.get("machineCode"):
                suspicious_indicators.append("missing_machine_code")
            
            if not device_info.get("os") or device_info.get("os") == "Unknown":
                suspicious_indicators.append("unknown_os")
            
            # æ£€æŸ¥ç™»å½•æ—¶é—´æ¨¡å¼
            recent_logins = list(self.login_logs.find({
                "phone": phone,
                "loginTime": {"$gte": datetime.now() - timedelta(days=7)},
                "loginResult": "success"
            }).sort("loginTime", -1).limit(10))
            
            if len(recent_logins) > 0:
                # æ£€æŸ¥ç™»å½•æ—¶é—´é—´éš”å¼‚å¸¸
                time_intervals = []
                for i in range(1, len(recent_logins)):
                    interval = (recent_logins[i-1]["loginTime"] - recent_logins[i]["loginTime"]).total_seconds()
                    time_intervals.append(interval)
                
                if time_intervals:
                    avg_interval = sum(time_intervals) / len(time_intervals)
                    if avg_interval < 300:  # å¹³å‡é—´éš”å°äº5åˆ†é’Ÿ
                        suspicious_indicators.append("frequent_login")
            
            # æ£€æŸ¥å¤šè®¾å¤‡ç™»å½•
            unique_machines = set()
            for login in recent_logins:
                machine_code = login.get("machineCode")
                if machine_code:
                    unique_machines.add(machine_code)
            
            if len(unique_machines) > 1:
                suspicious_indicators.append("multiple_devices")
            
            # è®°å½•å¯ç–‘æ´»åŠ¨
            if suspicious_indicators:
                self._log_abuse_event("suspicious_activity", phone, {
                    "indicators": suspicious_indicators,
                    "deviceInfo": device_info
                })
            
            return suspicious_indicators
            
        except Exception as e:
            print(f"æ£€æµ‹å¯ç–‘æ´»åŠ¨å¤±è´¥: {e}")
            return []
    
    def _log_abuse_event(self, event_type: str, target: str, details: Dict):
        """è®°å½•æ»¥ç”¨äº‹ä»¶"""
        try:
            log_entry = {
                "eventType": event_type,
                "target": target,
                "details": details,
                "timestamp": datetime.now(),
                "severity": self._get_event_severity(event_type)
            }
            self.abuse_logs.insert_one(log_entry)
        except Exception as e:
            print(f"è®°å½•æ»¥ç”¨æ—¥å¿—å¤±è´¥: {e}")
    
    def _get_event_severity(self, event_type: str) -> str:
        """è·å–äº‹ä»¶ä¸¥é‡ç¨‹åº¦"""
        severity_map = {
            "phone_rate_limit": "medium",
            "ip_rate_limit": "medium",
            "account_locked": "high",
            "suspicious_activity": "medium",
            "multiple_devices": "high"
        }
        return severity_map.get(event_type, "low")

# å…¨å±€é˜²åˆ·ç®¡ç†å™¨
anti_abuse = AntiAbuseManager(auth_api.db)
```

### **6.3 æƒé™æ§åˆ¶ç³»ç»Ÿ**

#### **åŸºäºè§’è‰²çš„æƒé™ç®¡ç†**
```python
class PermissionManager:
    """æƒé™ç®¡ç†å™¨"""
    
    def __init__(self, db):
        self.users = db["users"]
        self.roles = db["roles"]
        self.permissions = db["permissions"]
        
        # åˆå§‹åŒ–é»˜è®¤è§’è‰²å’Œæƒé™
        self._init_default_roles()
    
    def _init_default_roles(self):
        """åˆå§‹åŒ–é»˜è®¤è§’è‰²"""
        default_roles = [
            {
                "roleId": "basic_user",
                "name": "åŸºç¡€ç”¨æˆ·",
                "description": "æ™®é€šç”¨æˆ·æƒé™",
                "permissions": ["login", "view_movies", "create_order", "view_order_history"],
                "isDefault": True
            },
            {
                "roleId": "vip_user",
                "name": "VIPç”¨æˆ·",
                "description": "VIPç”¨æˆ·æƒé™",
                "permissions": ["login", "view_movies", "create_order", "view_order_history", "priority_booking", "discount_access"],
                "isDefault": False
            },
            {
                "roleId": "admin",
                "name": "ç®¡ç†å‘˜",
                "description": "ç³»ç»Ÿç®¡ç†å‘˜",
                "permissions": ["*"],  # æ‰€æœ‰æƒé™
                "isDefault": False
            }
        ]
        
        for role in default_roles:
            self.roles.update_one(
                {"roleId": role["roleId"]},
                {"$set": role},
                upsert=True
            )
    
    def check_permission(self, phone: str, permission: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æƒé™"""
        try:
            user = self.users.find_one({"phone": phone})
            if not user:
                return False
            
            # æ£€æŸ¥è´¦å·çŠ¶æ€
            if user.get("account", {}).get("status", {}).get("code", 1) != 1:
                return False
            
            # è·å–ç”¨æˆ·æƒé™
            user_permissions = user.get("account", {}).get("permissions", [])
            
            # æ£€æŸ¥æ˜¯å¦æœ‰é€šé…ç¬¦æƒé™
            if "*" in user_permissions:
                return True
            
            # æ£€æŸ¥å…·ä½“æƒé™
            return permission in user_permissions
            
        except Exception as e:
            print(f"æ£€æŸ¥æƒé™å¤±è´¥: {e}")
            return False
    
    def assign_role(self, phone: str, role_id: str) -> Dict:
        """åˆ†é…è§’è‰²"""
        try:
            # è·å–è§’è‰²ä¿¡æ¯
            role = self.roles.find_one({"roleId": role_id})
            if not role:
                return {"success": False, "message": "è§’è‰²ä¸å­˜åœ¨"}
            
            # æ›´æ–°ç”¨æˆ·æƒé™
            result = self.users.update_one(
                {"phone": phone},
                {
                    "$set": {
                        "account.role": role_id,
                        "account.permissions": role["permissions"],
                        "metadata.updatedAt": datetime.now()
                    }
                }
            )
            
            if result.modified_count > 0:
                return {"success": True, "message": "è§’è‰²åˆ†é…æˆåŠŸ"}
            else:
                return {"success": False, "message": "ç”¨æˆ·ä¸å­˜åœ¨"}
                
        except Exception as e:
            return {"success": False, "message": f"åˆ†é…å¤±è´¥: {str(e)}"}

# å…¨å±€æƒé™ç®¡ç†å™¨
permission_manager = PermissionManager(auth_api.db)
```
