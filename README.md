# 柴犬影院下单系统

## 项目概述
本项目为 Python 影院下单系统，支持多影院、多账号、多会员卡管理，集成选座、下单、价格计算等全流程，UI美观，交互流畅，所有功能均自动联动。

### ⚠️ 重要项目需求
**用户认证与设备授权机制**：
1. **读取当前设备机器码**：系统启动时自动读取当前设备的唯一机器码（基于硬件信息生成）
2. **API验证机制**：登录时将手机号和机器码发送到API服务器 (http://43.142.19.28:5000) 进行验证
3. **对比验证**：服务器端对比用户绑定的机器码与当前设备机器码是否一致
4. **登录控制**：
   - 如果机器码不一致：弹出提示"设备未授权，请联系管理员绑定设备"，不允许登录
   - 如果账号状态为禁用：弹出提示"账号已被禁用，请联系管理员"，不允许登录
   - 只有机器码匹配且账号状态正常的用户才能成功登录使用系统
5. **严格要求**：不允许随意修改此认证需求，这是系统的核心安全机制

**当前测试用户**：手机号 15155712316，API服务器绑定机器码 7DA491096E7B6854，状态启用，积分800

## 技术选型
- Python 3.x
- tkinter/ttkbootstrap（桌面UI）
- requests（API请求，已全局关闭SSL校验）
- JSON（本地与接口数据格式）
- 自定义服务层（如 `services/order_api.py`）
## 项目结构
```
cinema_order_simulator/
├── main.py                # 程序入口
├── ui/                    # 界面相关代码
│   ├── main_window.py     # 主界面UI（Tkinter实现）
│   ├── cinema_select_panel.py # 影院/影片/场次选择区
│   ├── seat_map_panel.py      # 座位图选择区
│   ├── account_panel.py       # 账号信息区
│   ├── account_list_panel.py  # 账号列表区
│   └── login_panel.py         # 登录面板
├── models/                # 数据模型
│   ├── account.py         # 账号模型
│   ├── cinema.py          # 影院模型
│   ├── movie.py           # 电影模型
│   ├── order.py           # 订单模型
├── services/              # 业务逻辑
│   ├── film_service.py    # 影片与场次服务
│   ├── order_service.py   # 下单相关逻辑
│   ├── payment_service.py # 支付相关逻辑
├── data/                  # 本地数据存储
│   ├── accounts.json      # 账号数据
│   ├── cinemas.json       # 影院数据
│   ├── movies.json        # 电影数据
│   └── orders.json        # 订单数据
└── README.md              # 项目说明文档
## 主要模块
- `ui/main_window.py`：主窗口，负责UI布局、账号/影院/场次/座位联动、下单逻辑。
- `ui/seat_map_panel.py`：座位图区域，Canvas自绘，底部集成"提交订单"按钮，自动显示选座与价格。
- `ui/cinema_select_panel.py`：影院、影片、日期、场次四级联动。
- `services/order_api.py`：下单API封装，所有请求 `verify=False`，自动兼容BOM。
- `data/accounts.json`：本地账号数据。

## 关键功能与实现
- 影院、账号、会员卡分离，账号通过 `cinemaid` 关联影院。
- 影院、影片、日期、场次四级下拉，自动联动。
- 选座区Canvas自绘，格子27x27，黑色边框，自动居中。
- 选中座位后，底部按钮实时显示所有已选座位及价格。
- "提交订单"按钮自动组装参数，调用API下单，弹窗提示结果。
- 所有API请求 `verify=False`，全局忽略SSL警告，兼容BOM。

## 代码健壮性与异常处理
- 主窗口初始化时显式定义所有关键属性，避免属性不存在报错。
- 账号、价格等属性均有默认值，避免空指针异常。
- 所有异常均有弹窗提示，用户体验友好。

## 冗余代码清理
- 已移除所有未用的旧UI、旧数据流、无用getter/setter等冗余代码，确保结构清晰。

## 环境与运行

### 系统要求
- Python 3.8+ (推荐Python 3.10+)
- Windows 10/11 (支持tkinter和PyQt5)
- 网络连接 (用于API调用)

### 依赖安装
项目已包含 `requirements.txt` 文件，包含所有必需的依赖包：

```bash
# 安装所有依赖
pip install -r requirements.txt
```

### 主要依赖包说明
- `requests>=2.25.0` - HTTP请求库，用于API调用
- `tkinter` - Python自带GUI库，主界面框架
- `ttkbootstrap>=1.10.0` - tkinter美化库，提供现代UI控件
- `PyQt5>=5.15.0` - 用户登录窗口GUI框架
- `Pillow>=8.0.0` - 图像处理库，用于二维码和订单图片处理
- `pywin32>=227` - Windows API访问，用于剪贴板操作

### 启动程序
```bash
# 方式1：使用完整Python路径启动（推荐）
D:/Python/python.exe main.py

# 方式2：如果已配置python命令别名
python main.py

# 方式3：在项目根目录执行
cd D:\cursor_data\乐影
D:/Python/python.exe main.py
```

**重要提示**：
- 请确保使用已安装所有依赖的Python版本
- 如果遇到模块导入错误，请使用完整的Python路径启动
- 当前测试通过的Python版本：Python 3.13.2 (D:/Python/python.exe)

### 首次启动说明
1. **用户认证**: 首次启动会显示PyQt5登录窗口，需要输入11位手机号进行用户认证
2. **机器码验证**: 登录窗口会显示当前设备的机器码，可复制用于账号绑定
3. **主界面**: 登录成功后自动显示tkinter主界面，开始使用影院下单功能

### 开发调试
- 本地开发调试不会消耗API额度，只有调用外部计费API才会消耗
- 所有API请求已配置 `verify=False`，忽略SSL证书验证
- 调试信息会在控制台输出，便于问题排查

### 常见问题解决
1. **ModuleNotFoundError**: 请确保已安装所有依赖 `pip install -r requirements.txt`
2. **PyQt5相关错误**: 确保系统支持GUI界面，在Windows Server等无桌面环境中可能无法运行
3. **网络连接错误**: 检查网络连接和API服务器状态
4. **机器码不匹配**: 
   - 错误信息：`Device not authorized` 或 HTTP 403
   - 解决方案：访问管理后台 http://43.142.19.28:5000/admin 更新用户机器码
   - 获取当前机器码：运行 `python debug_machine_code.py`
   - 将管理后台中对应用户的机器码更新为当前机器生成的机器码

### 🛠️ 调试工具
项目包含以下调试工具：
- `debug_machine_code.py` - 机器码生成调试工具，显示详细的硬件信息和机器码生成过程
- `update_server_machine_code.py` - 机器码更新助手，提供详细的更新步骤指导

## 后续开发规划与注意事项

### 1. 账号主账号标记
- 账号列表UI中用特殊标记（如加粗、颜色）区分主账号。
- 账号数据accounts.json增加`is_main`字段，切换影院时自动高亮主账号。

### 2. 切换事件清空券列表
- 切换账号、影院、影片、日期、场次等事件时，统一调用`update_coupons(None)`或类似方法清空券列表UI，防止券与订单不匹配。

### 3. 绑券Tab按钮位置
- 绑券Tab只包含券号输入和绑定按钮，**"取消账号下订单"按钮应在座位图区域右上方**。

### 4. 券操作强关联
- 所有涉及券的操作（如下单、刷新、绑定、取消）都要确保与当前账号、影院、场次等强关联，避免数据错乱。

### 5. UI一致性
- 各Tab的券列表、日志、订单详情等展示风格保持一致，提升用户体验。

### 6. 异常处理
- 所有接口请求、数据操作都要有异常捕获和友好提示，防止程序崩溃和用户困惑。

### 7. 数据持久化
- 影院、账号、券等信息的本地存储格式需统一，便于后续维护和扩展。

### 8. 代码结构解耦
- 各大功能模块（影院、账号、券、订单、座位）进一步解耦，便于独立开发和测试。

---

## 开发顺序建议
1. 账号主账号标记与高亮
2. 切换事件清空券列表
3. 绑券Tab与座位图区域按钮位置调整
4. 券操作强关联与数据一致性
5. UI风格统一与异常处理
6. 数据持久化格式统一
7. 代码结构优化与模块解耦

---

后续将严格按照上述规划逐步开发和优化，确保系统健壮、易用、可维护。

## 技术实现细节

### 用户认证与机器码管理

#### 1. 机器码生成与管理 ⭐

#### 真实机器码生成算法
系统现在使用基于硬件信息的真实机器码生成：

**硬件信息收集：**
- 计算机名：通过 `platform.node()` 获取
- 处理器信息：通过 `platform.processor()` 获取
- 系统信息：通过 `platform.system()` 和 `platform.release()` 组合
- 主板序列号：通过 `wmic baseboard get serialnumber` 命令获取
- CPU ID：通过 `wmic cpu get processorid` 命令获取  
- 硬盘序列号：通过 `wmic diskdrive get serialnumber` 命令获取

**机器码生成流程：**
1. 收集所有硬件信息并组合成字符串
2. 使用 SHA-256 哈希算法生成64位十六进制字符串
3. 截取前16位作为最终机器码
4. 机器码示例：`9DC6B72833DBFDA6`（基于当前设备硬件信息）

**重要变更记录：**
- ✅ **2024年修改**：从固定机器码 `"7DA491096E7B6854"` 改为基于硬件信息的真实机器码
- ✅ **安全增强**：每台设备都有唯一的机器码，无法轻易伪造
- ✅ **一致性保证**：同一设备多次获取机器码结果完全一致

**调试和测试工具：**
- `debug_machine_code.py`：显示机器码生成的详细过程和硬件信息
- `update_server_machine_code.py`：自动获取真实机器码并尝试更新到API服务器

#### 2. API服务器端点设计
**主要API端点** (http://43.142.19.28:5000):
- `POST /login` - 用户登录验证
  - 参数: phone, machineCode, timestamp
  - 验证: 手机号格式、机器码匹配、账号状态
  - 返回: 用户信息、token、积分等
- `POST /update_machine_code` - 更新用户机器码 **[新增功能]**
  - 参数: phone, machineCode, timestamp
  - 验证: 参数格式、用户存在性
  - 功能: 管理员可修改用户绑定的机器码
- `POST /update_user_points` - 更新用户积分
- `POST /toggle_user_status` - 切换用户状态（启用/禁用）
- `GET /admin` - 管理后台界面

#### 3. 机器码管理工具
**管理工具**: `admin_tool.py`
- **图形界面**: 基于tkinter的现代化管理界面
- **功能模块**:
  - 显示当前设备机器码，支持一键复制
  - 用户列表管理，支持实时编辑
  - 机器码修改：支持直接修改或使用当前机器码
  - 积分管理：实时调整用户积分
  - 状态管理：启用/禁用用户账号
- **安全特性**: 输入验证、确认对话框、错误处理

#### 4. API服务器增强功能
**管理后台界面增强** (基于Flask + HTML/JavaScript):
- **实时编辑**: 支持在线修改机器码、积分、状态
- **用户管理**: 添加、删除、编辑用户信息
- **响应式设计**: 适配不同屏幕尺寸
- **Ajax交互**: 无需刷新页面即可完成操作
- **数据验证**: 前端和后端双重验证确保数据安全

#### 5. 认证流程设计
```
1. 客户端启动 → 生成/获取机器码
2. 显示登录窗口 → 用户输入手机号
3. 发送登录请求 → API验证手机号+机器码
4. 验证成功 → 返回用户信息和权限
5. 定期检查 → 确保用户状态有效
```

#### 6. 登录窗口增强功能 ✅ **已修复**
**登录历史记忆功能**:
- **自动保存**: 登录成功后自动保存手机号到 `data/login_history.json`
- **自动填入**: 下次启动时自动填入上次登录的手机号，无需重复输入
- **时间记录**: 记录最后登录时间，便于追踪使用情况
- **错误修复**: 修复了时间获取错误，使用 `datetime` 模块替代 `QTimer`

**机器码显示功能**:
- **实时显示**: 登录界面显示当前设备机器码
- **一键复制**: 支持复制机器码到剪贴板，便于管理员录入
- **格式优化**: 使用等宽字体显示，便于识别

### 券列表错误处理增强 ✅ **已修复**

#### 1. 问题背景
在账号没有券或API返回异常数据时，程序会出现 `'NoneType' object has no attribute 'get'` 错误，导致券列表功能崩溃。

#### 2. 修复内容
**主窗口券列表处理** (`ui/main_window.py`):
- **None检查**: 增加对API返回None的安全检查
- **数据类型验证**: 确保返回数据是有效的字典类型
- **嵌套数据保护**: 对 `resultData` 和 `vouchers` 进行多层安全检查
- **券数据验证**: 确保每张券都是有效的字典对象

**影院选择面板券列表** (`ui/cinema_select_panel.py`):
- **统一错误处理**: 与主窗口保持一致的错误处理逻辑
- **安全显示**: 在各种异常情况下都能正常显示提示信息

**兑换券列表处理** (`ui/main_window.py` - `refresh_coupon_exchange_list`):
- **API响应检查**: 增强对API无响应情况的处理
- **数据结构验证**: 多层次验证数据结构的完整性
- **用户友好提示**: 不同错误情况显示不同的提示信息

#### 3. 错误处理逻辑
```python
# 修复前（会报错）
vouchers = coupon_result['resultData'].get('vouchers', [])

# 修复后（安全处理）
if coupon_result is None:
    return "API无响应"
if not isinstance(coupon_result, dict):
    return "数据格式错误"
result_data = coupon_result.get('resultData')
if result_data is None:
    return "券数据为空"
vouchers = result_data.get('vouchers', [])
```

#### 4. 测试验证
通过 `test_login_fixes.py` 测试脚本验证了以下场景：
- ✅ API返回None
- ✅ 返回空字典
- ✅ 返回错误响应
- ✅ resultData为None
- ✅ resultData为空字典
- ✅ vouchers为空列表
- ✅ 正常券数据处理

所有测试用例均通过，确保程序在各种异常情况下都能稳定运行。

### 下单前取消未付款订单功能

#### 12. 业务需求背景
- 小程序限制：同一账号不能有多个未付款订单，新下单前必须取消所有未付款订单
- 自动化处理：避免用户手动清理订单，提升下单成功率
- 批量处理：支持一次性取消多个未付款订单

#### 13. 技术实现
**新增API函数:**
- `cancel_order(params)`: 取消单个订单接口
  - 支持动态base_url构建，适配不同影院域名
  - 完整的BOM兼容和异常处理
  - 详细的调试日志输出

- `cancel_all_unpaid_orders(account, cinema)`: 批量取消未付款订单
  - 先获取订单列表，提取`unpaidorders`字段
  - 逐个调用取消接口，统计成功/失败数量
  - 返回详细的处理结果和失败订单信息

**下单流程优化:**
1. **步骤1**: 检查并取消未付款订单
2. **步骤2**: 构建座位信息
3. **步骤3**: 构建下单参数  
4. **步骤4**: 执行下单请求
5. **步骤5**: 获取订单可用优惠券
6. **步骤6**: 查询订单详情

#### 14. 用户体验设计
- **无未付款订单**: 静默处理，直接下单
- **成功取消**: 弹窗提示"已成功取消N个未付款订单，现在开始下单"
- **部分失败**: 警告提示失败详情，但继续尝试下单
- **完全失败**: 错误提示，阻止下单流程

#### 15. 调试与日志
- 每个步骤都有详细的控制台日志输出
- 包含订单号、影院、账号等关键信息
- 取消结果统计和失败原因记录
- 便于问题排查和性能监控

### 取消订单接口优化

#### 16. 取消订单返回值问题
- **问题现象**: 取消订单接口即使成功也返回401或其他错误码
- **解决方案**: 修改`cancel_all_unpaid_orders`函数，不判断返回结果，所有取消请求都认为成功
- **实现细节**:
  - 移除对`cancel_result.get('resultCode')`的判断
  - 所有发送的取消请求都计入`cancelledCount`
  - 返回结果中`failedCount`始终为0，`failedOrders`为空数组
  - 日志显示"已发送取消请求"而非"取消成功/失败"

#### 17. 用户体验优化
- 弹窗提示改为"已发送取消请求给N个订单，现在开始下单"
- 无论接口返回什么结果，都继续下单流程
- 避免因取消订单接口的"假失败"阻断下单

### 座位数据一致性排查

#### 18. 座位排数不一致问题
- **问题现象**: 同样场次在不同时间获取的座位数据排数可能不一致
- **可能原因**:
  - 影院后台座位数据实时更新
  - 不同API调用时间点的数据状态差异
  - 座位映射逻辑的边界处理
  
#### 19. 调试信息增强
- **新增调试输出**:
  - 原始座位数据总数统计
  - 所有排数和列数的完整范围
  - 最大排数和最大列数确认
  - 关键座位（2-6排，5-10列）的详细信息
  - 可用/已售座位数量统计
  
- **调试格式示例**:
  ```
  [座位数据调试] 原始座位数据总数: 120
  [座位数据调试] 所有排数: [1, 2, 3, 4, 5, 6, 7, 8]
  [座位数据调试] 所有列数: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
  [座位数据调试] 最大排数: 8, 最大列数: 12
  [关键座位] 排3列5: rn=3, cn=5, c=5, s=F, status=available
  ```

- **根因排查**: 通过详细的调试信息，可以快速定位座位数据差异的具体原因
- **数据一致性验证**: 确保不同时间点获取的座位数据具有相同的映射逻辑

### 座位排数映射问题修复

#### 20. 问题现象与根因
- **用户反馈**: "现在的3排对应的是二排"
- **问题分析**: 
  - API返回的排数为非连续序列：[1, 3, 5, 7]
  - 原代码创建7行数组，按`rn-1`索引填充，导致存在空行
  - 界面按连续序号显示排数，但实际映射关系错乱

#### 21. 修复方案
**核心思路**: 创建紧凑的座位图，消除空行，建立正确的映射关系

**技术实现**:
1. **动态行数计算**: 使用`len(all_rows)`而非`max(all_rows)`作为行数
2. **排号映射表**: 创建`row_mapping = {api_row: ui_row}`映射字典
3. **双重排数保存**: 
   - `seat['row']`: 保存原始API排数（用于下单）
   - `seat['ui_row']`: 保存界面显示排数（用于显示）
4. **显示修复**: 座位图标签使用`seat['row']`而非连续序号

**修复前**:
```
API排数: [1, 3, 5, 7]
数组创建: 7行 (有空行)
界面显示: 1,2,3,4,5,6,7排
实际映射: 1排✓, 2排空, 3排✓, 4排空, 5排✓, 6排空, 7排✓
```

**修复后**:
```
API排数: [1, 3, 5, 7]  
数组创建: 4行 (无空行)
界面显示: 1,3,5,7排
实际映射: 1排✓, 3排✓, 5排✓, 7排✓
```

#### 22. 调试信息增强
- **映射关系输出**: 清晰显示API排数到界面排数的映射
- **关键座位跟踪**: 详细输出重要座位的映射过程
- **尺寸验证**: 确认最终seat_map的准确尺寸

#### 23. 用户体验改进
- **准确座位选择**: 用户点击的排数与实际下单排数完全一致
- **清晰排数显示**: 界面显示真实的影院排数，无虚假连续性
- **数据一致性**: 选座、下单、取票码各环节排数信息保持一致

### 座位显示UI优化

#### 24. 用户体验问题
- **用户反馈**: "应该显示的是1 2 3 4排，但是中间也是有隔开的"
- **需求分析**: 
  - 界面显示友好的连续排号（1, 2, 3, 4）提升可读性
  - 保持排与排之间的实际物理间距，体现真实影院布局
  - 确保显示排号与下单数据的正确映射

#### 25. 优化方案
**设计理念**: 显示友好 + 布局真实 + 数据准确

**技术实现**:
1. **连续排号显示**: 界面标签使用`r+1`显示为1, 2, 3, 4排
2. **按比例间距布局**: 根据API排号间距调整行间距
   ```python
   # API排号: [1, 3, 5, 7]，间距为2
   # 每个排号间隔增加8像素，体现物理间距
   gap_pixels = pad_y + (row_gap - 1) * 8
   ```
3. **双重排号管理**:
   - **显示排号**: `display_row = r + 1` （用于界面显示）
   - **API排号**: `seat['row']` （用于下单提交）

#### 26. 布局计算逻辑
**间距计算公式**:
```
y坐标 = 基础间距 + 行高 * 行号 + Σ(排号差值-1) * 额外间距
```

**示例效果**:
- API排号 [1, 3, 5, 7] → 界面显示 [1, 2, 3, 4]
- 第1排和第2排之间：正常间距 + (3-1-1) * 8px = 正常间距 + 8px
- 第2排和第3排之间：正常间距 + (5-3-1) * 8px = 正常间距 + 8px
- 第3排和第4排之间：正常间距 + (7-5-1) * 8px = 正常间距 + 8px

#### 27. 数据一致性保障
- **界面显示**: "1排5座" （用户友好）
- **下单数据**: 仍使用API原始排号 "3排5座" （数据准确）
- **调试输出**: 清晰显示映射关系
  ```
  [DEBUG] 座位显示: 2排5座 (API: 3排5座)
  ```

#### 28. 用户体验提升
- **直观排号**: 连续的1, 2, 3, 4排，符合用户认知习惯
- **真实布局**: 保持影院实际的排间距，增强空间感
- **操作一致**: 选座显示和下单提交数据完全准确
- **视觉优化**: 排间距差异化，避免视觉密集感

### 座位数据映射根本问题修复

#### 29. 问题发现与诊断
- **用户报告**: "现在的3排对应的是二排"，提交的是"2排5座"而不是"3排5座"
- **数据分析**: 通过对比小程序座位图接口和下单数据，发现关键问题
- **误解纠正**: 我们之前误认为需要提交真实排号`rn`字段，但实际上小程序接口期望的是数据行号`r`字段

#### 30. 接口数据结构真相
**座位图接口返回数据结构**:
```json
{
  "r": 2,    // 数据中的连续行号(1,2,3,4) - 这是接口期望的值！
  "rn": 3,   // 真实影院排号(1,3,5,7) - 仅用于物理位置参考
  "c": 5,    // 数据中的连续列号
  "cn": 5,   // 真实列号
  "sn": "000000011111-5-3"  // 座位编号
}
```

**下单接口期望数据**:
```json
{
  "seatRow": 2,           // 期望的是r字段值，不是rn字段值！
  "seatInfo": "2排5座",   // 界面友好显示
  "seatNo": "000000011111-5-3"  // 座位编号匹配
}
```

#### 31. 根本性修复
**修复策略**: 彻底重构座位数据处理逻辑

**关键修改**:
1. **数据源切换**: 从使用`rn`字段改为使用`r`字段作为排号基准
2. **映射简化**: 不再需要复杂的排号映射，直接使用API返回的`r`字段
3. **显示统一**: 界面显示和下单提交都使用相同的`r`字段值

**修复前后对比**:
```python
# 修复前（错误）
api_row = int(seat['rn'])  # 使用真实排号
seat['row'] = api_row      # 下单时提交真实排号
# 结果：界面显示2排，实际提交3排（错误）

# 修复后（正确）  
data_row = int(seat['r'])  # 使用数据行号
seat['row'] = data_row     # 下单时提交数据行号
# 结果：界面显示2排，实际提交2排（正确）
```

#### 32. 数据一致性保障
**完整数据保存**:
- `seat['row']`: 数据行号，用于界面显示和下单提交
- `seat['real_row']`: 真实排号，仅用于参考
- `seat['r']`: 原始r字段备份
- `seat['rn']`: 原始rn字段备份

**调试信息优化**:
```
[座位数据调试] 数据行号(r): [1, 2, 3, 4]
[座位数据调试] 真实排号(rn): [1, 3, 5, 7]
[DEBUG] 座位显示: 2排5座 (数据r=2, 真实rn=3)
```

#### 33. 修复验证结果
- **✅ 界面显示**: 2排5座（用户友好）
- **✅ 下单数据**: `seatRow: 2`（接口期望）
- **✅ 座位编号**: `seatNo: "000000011111-5-3"`（完全匹配）
- **✅ 数据一致**: 选座→显示→下单→取票全链路数据统一

#### 34. 经验总结
- **API理解**: 仔细分析接口期望的数据格式，不能凭主观推测
- **数据追踪**: 通过完整的接口数据对比发现问题根源  
- **调试重要性**: 详细的调试输出帮助快速定位问题
- **用户反馈价值**: 用户的直观反馈往往指向核心问题

# 乐影 - 电影票务系统

## 项目概括
本项目是一个基于Python的电影票务管理系统，支持多影院账号管理、座位选择、订单处理、优惠券绑定等功能。

## 最新更新：用户管理系统优化

### 🆕 认证系统重大优化 (2024-01-24)

**核心改进**：
- ✅ **简化登录流程**：去掉密码验证，改为手机号+机器码绑定
- ✅ **增强安全性**：每个手机号只能绑定一台设备
- ✅ **用户体验提升**：无需记忆密码，输入手机号即可登录
- ✅ **管理便捷性**：管理员可轻松添加/删除用户

### 轻量级用户授权方案
**适用场景**：30-40个用户，零服务器运维需求
**技术栈**：腾讯云开发 + Python客户端
**成本**：完全免费（在免费额度内）

### 系统架构图
```
客户端软件 ←→ 腾讯云函数 API ←→ 腾讯云数据库
    ↓
手机号 + 机器码验证 + 登录认证 + 积分管理
```

### 核心功能模块
1. **用户认证模块**
   - **手机号登录**：支持11位中国手机号格式验证
   - **机器码绑定**：基于硬件信息生成唯一设备标识
   - **Token管理**：登录后生成访问令牌，支持会话管理

2. **权限控制模块**
   - 账号状态检查（开启/关闭）
   - 软件功能访问控制
   - 实时权限验证（30秒间隔）

3. **积分系统模块**
   - 积分余额管理
   - 自动积分扣除
   - 操作记录追踪

4. **后台管理模块**
   - 用户管理界面
   - 积分充值/扣除
   - 账号状态控制

### 数据库设计
```sql
-- 用户表
users: {
  id: string,
  phone: string,        // 手机号 (11位)
  username: string,     // 用户昵称
  machine_code: string, // 绑定的机器码
  status: number,       // 1=开启, 0=关闭
  points: number,       // 积分余额
  created_at: date,
  last_login: date
}

-- 积分记录表
point_logs: {
  id: string,
  user_id: string,
  operation: string,     // 操作类型
  points_used: number,
  remaining_points: number,
  created_at: date
}
```

### API接口设计
```python
# 主要API端点
POST /login          # 手机号登录 (phone + machine_code)
POST /check_auth     # 验证用户状态
POST /use_points     # 扣除积分
GET /user_info       # 获取用户信息
POST /admin/users    # 管理员接口
```

## 技术选型
- 主要编程语言: Python 3.10+
- 桌面UI框架: PyQt5/6
- 云服务: 腾讯云开发
- 数据库: 腾讯云数据库 (NoSQL)
- 认证: JWT Token + 机器码绑定
- 加密: hashlib + 自定义算法

## 用户认证系统 - 实施完成状态

### ✅ 已完成功能

1. **核心认证模块** (`services/auth_service.py`)
   - ✅ 机器码生成与绑定验证
   - ✅ 手机号格式验证（中国11位格式）
   - ✅ 用户登录验证（无需密码）
   - ✅ 权限状态检查
   - ✅ Token管理
   - ✅ 积分系统（扣除/余额管理）

2. **登录界面** (`ui/login_window.py`)
   - ✅ 现代化PyQt5界面设计
   - ✅ 手机号输入框（11位限制）
   - ✅ 异步登录验证
   - ✅ 机器码显示
   - ✅ 登录状态反馈
   - ✅ 使用说明提示

3. **主窗口集成** (`ui/main_window.py`)
   - ✅ 启动时强制登录
   - ✅ 定期权限检查（30秒间隔）
   - ✅ 权限失效自动重登录
   - ✅ 窗口标题显示用户信息
   - ✅ 操作前权限验证
   - ✅ 积分自动扣除

4. **模拟API系统**
   - ✅ 本地模拟用户数据库
   - ✅ 完整的API响应格式
   - ✅ 错误处理机制
   - ✅ 预置测试账号

### 🎯 测试验证结果

**测试脚本**: `test_auth_system.py`

| 功能模块 | 状态 | 测试结果 |
|----------|------|----------|
| 机器码生成 | ✅ 通过 | 生成唯一且一致的32位MD5码 |
| 手机号验证 | ✅ 通过 | 正确识别有效/无效手机号格式 |
| 模拟登录 | ✅ 通过 | 正确手机号登录成功，错误信息准确 |
| 权限验证 | ✅ 通过 | 登录状态检查，未登录正确拒绝 |
| 积分系统 | ✅ 通过 | 积分扣除正常，不足时正确提示 |
| 登录界面 | ✅ 通过 | PyQt5界面显示正常，交互流畅 |

**当前机器码**: `6fbae16cd7f2b470160c6469ce22aa67`

### 📋 预置测试账号

| 手机号 | 用户名 | 积分 | 状态 | 说明 |
|--------|--------|------|------|------|
| 13800138000 | 管理员 | 100 | 正常 | 系统管理员账号 |
| 13900139000 | 测试用户 | 50 | 正常 | 测试用途账号 |
| 13700137000 | 普通用户 | 30 | 正常 | 普通用户账号 |
| 15155712316 | 用户 | 80 | 正常 | 新增用户账号 |

### 🚀 使用指南

#### 1. 首次使用
```bash
# 测试认证系统
python test_auth_system.py

# 启动主程序（会自动弹出登录窗口）
python main.py
```

#### 2. 登录操作
- 软件启动时会自动显示登录窗口
- 输入11位手机号（如：13800138000）
- 系统会验证手机号格式和机器码绑定
- 登录成功后显示主窗口

#### 3. 权限管理
- 软件会每30秒自动检查用户权限
- 账号被禁用时会强制重新登录
- 积分不足时会阻止相关操作

#### 4. 积分系统
- 登录后窗口标题显示当前积分
- 特定操作会自动扣除积分
- 积分不足时操作被阻止

### 🔧 用户管理工具

#### 启动用户管理器
```bash
python user_manager.py
```

#### 主要功能
- **查看用户列表**：显示所有用户信息
- **添加新用户**：输入手机号、用户名、初始积分
- **修改用户信息**：更新用户名、状态、积分、机器码
- **删除用户**：删除指定用户
- **积分管理**：增减积分或设置积分值
- **导出云端数据**：生成云端部署数据文件

### 🌐 云端部署（可选）

如需部署到云端实现真正的多用户管理：

1. **查看部署指南**: `云端部署指南.md`
2. **替换API地址**: 修改 `auth_service.py` 中的云函数地址
3. **配置数据库**: 在腾讯云开发中创建用户数据表

### 📊 系统架构

```
启动流程:
主程序启动 → 隐藏主窗口 → 显示登录窗口 → 验证成功 → 显示主窗口 → 定期权限检查

权限验证:
用户操作 → 检查登录状态 → 验证积分 → 扣除积分 → 执行操作

数据流:
客户端 ←→ AuthService ←→ 模拟API / 云端API ←→ 用户数据
```

### 🔧 自定义配置

#### 添加新用户
使用用户管理工具 `python user_manager.py` 或修改 `auth_service.py` 中的 `mock_users` 字典:
```python
"13912345678": {
    "id": "user_004",
    "phone": "13912345678",
    "username": "新用户",
    "machine_code": machine_code,  # 目标机器码
    "status": 1,
    "points": 30
}
```

#### 修改积分消耗
在需要扣除积分的操作前调用:
```python
if not self.use_points_for_action("操作名称", 积分数量):
    return  # 积分不足，阻止操作
```

#### 调整权限检查频率
修改 `main_window.py` 中的检查间隔:
```python
self.auth_check_timer = self.after(30000, check_auth)  # 30秒改为其他值
```

### 💡 下一步计划

1. **云端部署**: 部署到腾讯云开发，实现真正的多用户管理
2. **后台管理**: 创建Web管理界面，方便管理员操作
3. **高级功能**: 添加邮件通知、操作日志、数据统计等功能
4. **安全增强**: 实施更严格的Token验证和加密机制

### 🎉 总结

用户认证系统已完全实现并测试通过，具备：
- ✅ **简化登录**: 手机号 + 机器码，无需记忆密码
- ✅ **设备绑定**: 一个手机号只能在一台设备上使用
- ✅ **易用性**: 现代化登录界面 + 自动权限管理
- ✅ **扩展性**: 模块化设计 + 云端部署支持
- ✅ **稳定性**: 完整错误处理 + 定期权限检查

系统现在可以安全地分发给用户使用，每个用户只需使用已注册的手机号即可在绑定的设备上登录，管理员可以通过积分系统控制用户的操作权限。

## 开发状态跟踪

| 模块/功能                    | 状态     | 负责人 | 计划完成日期 | 实际完成日期 | 备注与链接                                    |
|------------------------------|----------|--------|--------------|--------------|-----------------------------------------------|
| 用户认证系统                 | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | [认证模块](#用户认证与机器码管理)             |
| 登录窗口(PyQt5)              | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 支持机器码显示和复制                          |
| 登录历史记忆功能             | ✅ 已完成 | AI     | 2024-12-29   | 2024-12-29   | 自动保存/加载手机号，修复时间获取错误         |
| 主窗口界面(tkinter)          | ✅ 已完成 | AI     | 2024-12-18   | 2024-12-18   | 五栏布局，账号/影院/座位联动                  |
| 影院选择面板                 | ✅ 已完成 | AI     | 2024-12-18   | 2024-12-18   | 四级联动：影院→影片→日期→场次                |
| 座位图显示                   | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | Canvas绘制，支持多选，实时价格计算            |
| 账号列表管理                 | ✅ 已完成 | AI     | 2024-12-18   | 2024-12-18   | 支持主账号标记，余额显示                      |
| 下单流程                     | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | 完整下单→查询→券选择→支付流程                |
| 券列表显示与选择             | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | 支持多选，实时价格计算                        |
| 券列表错误处理增强           | ✅ 已完成 | AI     | 2024-12-29   | 2024-12-29   | 修复NoneType错误，增强API异常处理             |
| 订单支付功能                 | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | 支持券支付，自动查询订单详情                  |
| 订单详情显示                 | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | 实时倒计时，支付状态跟踪                      |
| 取票码二维码生成             | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 合成订单图片，支持复制                        |
| 券绑定功能                   | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | 批量绑定，进度显示，日志记录                  |
| 订单列表查询                 | ✅ 已完成 | AI     | 2024-12-19   | 2024-12-19   | 支持双击查看详情，右键取消订单                |
| 兑换券列表查询               | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 按有效期统计，过滤已用/过期券                 |
| 影院管理功能                 | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 添加/删除影院，API验证                        |
| 机器码管理工具               | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 图形化管理界面，支持批量操作                  |
| API服务器管理后台            | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | Web界面，用户/机器码/积分管理                 |
| 错误处理与用户体验优化       | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 统一错误提示，操作确认机制                    |
| 部署文档与使用指南           | ✅ 已完成 | AI     | 2024-12-20   | 2024-12-20   | 完整的安装、配置、使用说明                    |

### 📁 项目文件清单
**主要程序文件**:
- `main.py` - 主程序入口
- `admin_tool.py` - **[新增]** 机器码管理工具（图形界面）
- `server_api_sample.py` - **[新增]** API服务器示例代码
- `test_machine_code_api.py` - **[新增]** API功能测试脚本

**启动脚本**:
- `启动程序.bat` - 启动主程序
- `启动管理工具.bat` - **[新增]** 启动管理工具

**服务模块** (services/):
- `auth_service.py` - 用户认证服务
- `admin_api.py` - **[新增]** 管理API服务
- `cinema_service.py` - 影院数据服务
- `movie_service.py` - 电影数据服务
- `order_service.py` - 订单处理服务

**界面模块** (ui/):
- `login_ui.py` - 登录界面
- `main_ui.py` - 主界面
- `cinema_ui.py` - 影院选择界面
- `movie_ui.py` - 电影选择界面
- `seat_ui.py` - 选座界面
- `order_ui.py` - 订单界面

**配置与数据**:
- `requirements.txt` - 依赖包列表
- `README.md` - 项目文档
- `result.json` - 订单结果数据
- `万友影城最新排期.json` - 影院排期数据
```

## 🔧 三个核心问题深度修复记录 (2025-01-28 最终版)

### 🎯 问题总结与解决方案

#### 1️⃣ **5分钟认证检查机制优化**
**用户需求**: 需要真实的API验证，而不是假数据检查  
**修复方案**:
- ✅ **使用真实登录API**: 5分钟检查改为调用 `http://43.142.19.28:5000/login`
- ✅ **确保账号机器码匹配**: 每次检查都验证手机号+机器码组合
- ✅ **移除假数据逻辑**: 完全依赖API服务器返回的真实数据
- ✅ **保持认证状态同步**: 检查成功后更新本地用户信息（积分等）

**技术实现**:
```python
# services/auth_service.py - check_auth方法
def check_auth(self) -> Tuple[bool, str, Optional[Dict]]:
    # 使用真实的登录API进行认证检查
    phone = self.current_user.get("phone") or self.current_user.get("username")
    machine_code = self.get_machine_code()
    
    # 构建与登录时相同的请求参数
    login_data = {
        "phone": phone,
        "machineCode": machine_code,
        "timestamp": int(time.time())
    }
    
    # 调用登录API进行验证
    response = self._call_api("login", login_data)
```

#### 2️⃣ **机器码生成稳定性修复**
**问题现象**: 机器码在不同时间生成结果不一致  
**根本原因**: 硬件信息获取顺序不固定，系统版本信息可能变化  
**修复方案**:
- ✅ **使用有序字典**: 确保硬件信息收集顺序一致
- ✅ **按键名排序**: 组合硬件信息前先对键名排序
- ✅ **移除易变信息**: 去掉 `platform.release()` 等可能变化的字段
- ✅ **固定组合格式**: 统一使用 `key:value|key:value` 格式

**修复前后对比**:
```
修复前: A830579E12B25F4C (不稳定)
修复后: 91F16A48D96494E3 (稳定)
```

**技术实现**:
```python
# 使用有序字典收集硬件信息
hardware_info = {}
hardware_info["computer"] = platform.node()
hardware_info["processor"] = platform.processor()
hardware_info["system"] = f"{platform.system()}-{platform.machine()}"  # 移除release

# 按键名排序并组合
sorted_keys = sorted(hardware_info.keys())
combined_parts = []
for key in sorted_keys:
    combined_parts.append(f"{key}:{hardware_info[key]}")
combined_info = "|".join(combined_parts)
```

#### 3️⃣ **程序关闭机制完善**
**问题现象**: 关闭客户端后程序进程仍在运行  
**根本原因**: Qt应用程序和定时器没有正确清理  
**修复方案**:
- ✅ **绑定关闭事件**: 使用 `protocol("WM_DELETE_WINDOW", self.on_closing)`
- ✅ **清理定时器**: 停止5分钟认证检查定时器
- ✅ **退出Qt应用**: 正确调用 `qt_app.quit()`
- ✅ **资源清理**: 清除用户信息和窗口引用

**技术实现**:
```python
def on_closing(self):
    """窗口关闭事件处理"""
    # 停止定期认证检查
    if hasattr(self, 'auth_check_timer') and self.auth_check_timer:
        self.after_cancel(self.auth_check_timer)
    
    # 退出Qt应用程序
    if hasattr(self, 'qt_app'):
        self.qt_app.quit()
    
    # 销毁主窗口
    self.destroy()
```

### 📊 修复验证结果

**测试通过率**: 100% (3/3)
- ✅ 机器码生成稳定性: 通过
- ✅ 认证检查API调用: 通过  
- ✅ 程序启动关闭: 通过

**当前稳定机器码**: `91F16A48D96494E3`

### 🔄 软件运行逻辑确认

**完整认证流程**:
1. **启动阶段**: 显示登录窗口，展示当前设备机器码
2. **登录验证**: 输入手机号 → 读取机器码 → 调用API验证 → 匹配成功允许登录
3. **运行阶段**: 每5分钟自动调用登录API验证账号+机器码
4. **异常处理**: 验证失败自动弹出重新登录窗口
5. **关闭阶段**: 清理所有资源，确保进程完全退出

**API调用接口**: `http://43.142.19.28:5000/login`  
**验证参数**: `{"phone": "手机号", "machineCode": "设备机器码", "timestamp": 时间戳}`

### 💡 用户使用指南

1. **首次使用**: 启动程序后复制显示的机器码给管理员录入系统
2. **日常使用**: 输入手机号登录，程序会自动记忆手机号
3. **认证机制**: 登录后每5分钟自动验证，无需手动操作
4. **异常处理**: 如提示认证失败，重新登录即可
5. **程序关闭**: 直接关闭窗口，程序会自动清理并完全退出

---

*修复完成时间: 2025-01-28*  
*验证状态: 全部通过*  
*稳定机器码: 91F16A48D96494E3*