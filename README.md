# 柴犬影院下单系统

## 项目概述
本项目为 Python 影院下单系统，支持多影院、多账号、多会员卡管理，集成选座、下单、价格计算等全流程，UI美观，交互流畅，所有功能均自动联动。

## 技术选型
- Python 3.x
- tkinter/ttkbootstrap（桌面UI）
- requests（API请求，已全局关闭SSL校验）
- JSON（本地与接口数据格式）
- 自定义服务层（如 `services/order_api.py`）
## 项目结构
```
cinema_order_simulator/
├── main.py                # 程序入口
├── ui/                    # 界面相关代码
│   ├── main_window.py     # 主界面UI（Tkinter实现）
│   ├── cinema_select_panel.py # 影院/影片/场次选择区
│   ├── seat_map_panel.py      # 座位图选择区
│   ├── account_panel.py       # 账号信息区
│   ├── account_list_panel.py  # 账号列表区
│   └── login_panel.py         # 登录面板
├── models/                # 数据模型
│   ├── account.py         # 账号模型
│   ├── cinema.py          # 影院模型
│   ├── movie.py           # 电影模型
│   ├── order.py           # 订单模型
├── services/              # 业务逻辑
│   ├── film_service.py    # 影片与场次服务
│   ├── order_service.py   # 下单相关逻辑
│   ├── payment_service.py # 支付相关逻辑
├── data/                  # 本地数据存储
│   ├── accounts.json      # 账号数据
│   ├── cinemas.json       # 影院数据
│   ├── movies.json        # 电影数据
│   └── orders.json        # 订单数据
└── README.md              # 项目说明文档
## 主要模块
- `ui/main_window.py`：主窗口，负责UI布局、账号/影院/场次/座位联动、下单逻辑。
- `ui/seat_map_panel.py`：座位图区域，Canvas自绘，底部集成"提交订单"按钮，自动显示选座与价格。
- `ui/cinema_select_panel.py`：影院、影片、日期、场次四级联动。
- `services/order_api.py`：下单API封装，所有请求 `verify=False`，自动兼容BOM。
- `data/accounts.json`：本地账号数据。

## 关键功能与实现
- 影院、账号、会员卡分离，账号通过 `cinemaid` 关联影院。
- 影院、影片、日期、场次四级下拉，自动联动。
- 选座区Canvas自绘，格子27x27，黑色边框，自动居中。
- 选中座位后，底部按钮实时显示所有已选座位及价格。
- "提交订单"按钮自动组装参数，调用API下单，弹窗提示结果。
- 所有API请求 `verify=False`，全局忽略SSL警告，兼容BOM。

## 代码健壮性与异常处理
- 主窗口初始化时显式定义所有关键属性，避免属性不存在报错。
- 账号、价格等属性均有默认值，避免空指针异常。
- 所有异常均有弹窗提示，用户体验友好。

## 冗余代码清理
- 已移除所有未用的旧UI、旧数据流、无用getter/setter等冗余代码，确保结构清晰。

## 环境与运行
- 依赖：`requests`, `tkinter`, `ttkbootstrap`
- 运行：`python main.py`
- 本地开发调试不会消耗API额度，只有调用外部计费API才会消耗。

## 后续开发规划与注意事项

### 1. 账号主账号标记
- 账号列表UI中用特殊标记（如加粗、颜色）区分主账号。
- 账号数据accounts.json增加`is_main`字段，切换影院时自动高亮主账号。

### 2. 切换事件清空券列表
- 切换账号、影院、影片、日期、场次等事件时，统一调用`update_coupons(None)`或类似方法清空券列表UI，防止券与订单不匹配。

### 3. 绑券Tab按钮位置
- 绑券Tab只包含券号输入和绑定按钮，**"取消账号下订单"按钮应在座位图区域右上方**。

### 4. 券操作强关联
- 所有涉及券的操作（如下单、刷新、绑定、取消）都要确保与当前账号、影院、场次等强关联，避免数据错乱。

### 5. UI一致性
- 各Tab的券列表、日志、订单详情等展示风格保持一致，提升用户体验。

### 6. 异常处理
- 所有接口请求、数据操作都要有异常捕获和友好提示，防止程序崩溃和用户困惑。

### 7. 数据持久化
- 影院、账号、券等信息的本地存储格式需统一，便于后续维护和扩展。

### 8. 代码结构解耦
- 各大功能模块（影院、账号、券、订单、座位）进一步解耦，便于独立开发和测试。

---

## 开发顺序建议
1. 账号主账号标记与高亮
2. 切换事件清空券列表
3. 绑券Tab与座位图区域按钮位置调整
4. 券操作强关联与数据一致性
5. UI风格统一与异常处理
6. 数据持久化格式统一
7. 代码结构优化与模块解耦

---

后续将严格按照上述规划逐步开发和优化，确保系统健壮、易用、可维护。

## 技术实现细节

### 订单支付（全部用券支付）API

#### 1. coupon_pay_order(params: dict) -> dict
- 功能：调用MiniPay/couponPay接口，支持全部用券支付订单。支付成功后自动调用get_order_detail查单。
- 参数说明：
    - orderno: 订单号（字符串，必填）
    - payprice: 实际支付金额（字符串，必填，全部用券时为0）
    - discountprice: 优惠金额（字符串，必填，全部用券时为总票价）
    - couponcodes: 券号字符串，多个券号用英文逗号分隔（如'123,456'）
    - groupid, cinemaid, cardno, userid, openid, CVersion, OS, token, source: 参考下单参数，均需传递
- 返回值：
    - 若支付成功（resultCode=="0"），返回{"resultCode": "0", "resultDesc": "支付成功，已查单", "resultData": <订单详情dict>}。
    - 若失败，返回原始支付接口返回内容。
- 异常处理：
    - 网络或接口异常时，返回{"resultCode": "-1", "resultDesc": "支付请求异常: ...", "resultData": None}

#### 2. get_order_detail(params: dict) -> dict
- 功能：调用MiniOrder/getOrderDetail接口，查询订单详情。
- 参数说明：
    - orderno, groupid, cinemaid, cardno, userid, openid, CVersion, OS, token, source: 均为字符串，必填。
- 返回值：接口返回的订单详情dict。
- 异常处理：
    - 网络或接口异常时，返回{"resultCode": "-1", "resultDesc": "查单请求异常: ...", "resultData": None}

#### 3. get_order_qrcode_api(orderno: str) -> bytes
- 功能：获取订单取票二维码图片，返回图片二进制内容。
- 参数：orderno（订单号，字符串）
- 返回值：二维码图片二进制内容，异常或失败时返回None。
- 异常处理：网络或接口异常时返回None。

#### 4. get_order_list(params: dict) -> dict
- 功能：获取订单列表，调用MiniOrder/getOrderList接口。
- 参数说明：
    - pageNo, groupid, cinemaid, cardno, userid, openid, CVersion, OS, token, source：均为字符串，必填。
- 返回值：接口返回的订单列表dict，orders字段为订单数组。
- 异常处理：网络或接口异常时，返回{"resultCode": "-1", "resultDesc": "订单列表请求异常: ...", "resultData": None}

- 所有API请求均严格模拟小程序请求头，verify=False，自动兼容BOM。

### 接口返回值BOM兼容规范
- 所有API接口返回值必须兼容UTF-8 BOM，统一采用如下处理：
    - 优先resp.json()，如失败则json.loads(resp.content.decode('utf-8-sig'))。
- 任何新开发或维护的接口，必须遵循此规范，彻底避免"Unexpected UTF-8 BOM"相关异常。

### 订单详情与二维码合成功能

#### 5. show_order_qrcode_img(detail, qrcode_img_bytes)
- 功能：根据订单详情和二维码图片，合成美观的订单取票图片并在取票码区显示。
- 实现要点：
    - 图片尺寸：320x420像素，白色背景（优化尺寸，减少留白）
    - 字体：优先使用msyh.ttc（微软雅黑），分级设置（标题18pt，正文12pt，取票码15pt，提示10pt）
    - 布局结构：
        1. 电影名称（标题，18pt，黑色）
        2. 场次时间（12pt，深灰色#555）
        3. 影厅座位信息（12pt，深灰色#555）
        4. "取票"分割线和标题
        5. 二维码（140x140，居中，增大尺寸提升扫码体验）
        6. 取票码（15pt，橙色#ff6600，居中突出显示）
        7. 提示文字（10pt，浅灰色#999，居中）
        8. "订单详情"分割线和标题
        9. 订单信息（紧凑布局：实付金额、影院名称、手机号码、订单号、购买时间）
- 优化改进：
    - 边距从20px减少到12px，充分利用空间
    - 行间距统一为15px，布局更紧凑
    - 长文本智能截断（影院名超过15字符显示省略号，订单号超过16位分行显示）
    - 二维码加载失败时显示占位图案
- 图片命名规则：影院名+当前月日+订单号.png（如：深圳万影城0523_20250523123456.png）
- 保存路径：data/img/目录下
- UI集成：
    - 复制路径、复制图片按钮位于取票码区顶部
    - 使用Canvas+Scrollbar实现可滚动图片显示，避免图片被截断
    - 复制操作成功后无弹窗提示（静默复制）

#### 6. UI布局优化
- 右侧布局比例调整：取票码区占65%，订单详情区占35%
- 取票码区域有足够空间完整显示订单详情图片
- 复制图片功能集成win32clipboard，支持将图片直接复制到系统剪贴板
- 图片显示区域自适应，确保用户能看到完整的订单信息和二维码

### 选座失败问题排查与修复

#### 7. 问题现象
- 用户选座时出现"选座失败"提示
- 日志显示价格信息被意外清空：`last_priceinfo = None`
- 界面显示座位已选中但价格计算异常

#### 8. 问题根因分析
1. **影院选择面板**中的调试打印语句错误：访问了`self.last_priceinfo`而非`self.master.master.last_priceinfo`
2. **主窗口**的`on_seat_selected`方法在每次选座时都调用`self.clear_coupons()`，虽然不直接影响价格，但会干扰选座体验
3. **价格信息传递时序问题**：座位图更新和价格信息设置存在时序竞争

#### 9. 修复措施
- **修复调试语句**：将`getattr(self, 'last_priceinfo', None)`改为`getattr(self.master.master, 'last_priceinfo', None)`
- **优化选座逻辑**：暂时注释掉`on_seat_selected`中的`clear_coupons()`调用，避免影响选座流程
- **增强调试信息**：在关键方法中添加详细的调试打印，便于后续问题排查：
  - `SeatMapPanel.set_priceinfo()`：打印接收到的价格信息
  - `SeatMapPanel.update_info_label()`：打印价格计算过程和最终按钮文本
  - `main_window.on_seat_selected()`：打印选座状态和价格信息

#### 10. 代码健壮性提升
- 价格信息获取时增加空值保护：`priceinfo or {}`
- 座位信息显示时增加数据验证和异常处理
- 调试信息分级输出，生产环境可关闭DEBUG级别日志

#### 11. 后续优化建议
- 考虑重构价格信息传递机制，使用观察者模式或状态管理
- 建立统一的调试日志框架，便于问题追踪
- 对关键业务流程建立单元测试，避免回归问题

### 下单前取消未付款订单功能

#### 12. 业务需求背景
- 小程序限制：同一账号不能有多个未付款订单，新下单前必须取消所有未付款订单
- 自动化处理：避免用户手动清理订单，提升下单成功率
- 批量处理：支持一次性取消多个未付款订单

#### 13. 技术实现
**新增API函数:**
- `cancel_order(params)`: 取消单个订单接口
  - 支持动态base_url构建，适配不同影院域名
  - 完整的BOM兼容和异常处理
  - 详细的调试日志输出

- `cancel_all_unpaid_orders(account, cinema)`: 批量取消未付款订单
  - 先获取订单列表，提取`unpaidorders`字段
  - 逐个调用取消接口，统计成功/失败数量
  - 返回详细的处理结果和失败订单信息

**下单流程优化:**
1. **步骤1**: 检查并取消未付款订单
2. **步骤2**: 构建座位信息
3. **步骤3**: 构建下单参数  
4. **步骤4**: 执行下单请求
5. **步骤5**: 获取订单可用优惠券
6. **步骤6**: 查询订单详情

#### 14. 用户体验设计
- **无未付款订单**: 静默处理，直接下单
- **成功取消**: 弹窗提示"已成功取消N个未付款订单，现在开始下单"
- **部分失败**: 警告提示失败详情，但继续尝试下单
- **完全失败**: 错误提示，阻止下单流程

#### 15. 调试与日志
- 每个步骤都有详细的控制台日志输出
- 包含订单号、影院、账号等关键信息
- 取消结果统计和失败原因记录
- 便于问题排查和性能监控

### 取消订单接口优化

#### 16. 取消订单返回值问题
- **问题现象**: 取消订单接口即使成功也返回401或其他错误码
- **解决方案**: 修改`cancel_all_unpaid_orders`函数，不判断返回结果，所有取消请求都认为成功
- **实现细节**:
  - 移除对`cancel_result.get('resultCode')`的判断
  - 所有发送的取消请求都计入`cancelledCount`
  - 返回结果中`failedCount`始终为0，`failedOrders`为空数组
  - 日志显示"已发送取消请求"而非"取消成功/失败"

#### 17. 用户体验优化
- 弹窗提示改为"已发送取消请求给N个订单，现在开始下单"
- 无论接口返回什么结果，都继续下单流程
- 避免因取消订单接口的"假失败"阻断下单

### 座位数据一致性排查

#### 18. 座位排数不一致问题
- **问题现象**: 同样场次在不同时间获取的座位数据排数可能不一致
- **可能原因**:
  - 影院后台座位数据实时更新
  - 不同API调用时间点的数据状态差异
  - 座位映射逻辑的边界处理
  
#### 19. 调试信息增强
- **新增调试输出**:
  - 原始座位数据总数统计
  - 所有排数和列数的完整范围
  - 最大排数和最大列数确认
  - 关键座位（2-6排，5-10列）的详细信息
  - 可用/已售座位数量统计
  
- **调试格式示例**:
  ```
  [座位数据调试] 原始座位数据总数: 120
  [座位数据调试] 所有排数: [1, 2, 3, 4, 5, 6, 7, 8]
  [座位数据调试] 所有列数: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
  [座位数据调试] 最大排数: 8, 最大列数: 12
  [关键座位] 排3列5: rn=3, cn=5, c=5, s=F, status=available
  ```

- **根因排查**: 通过详细的调试信息，可以快速定位座位数据差异的具体原因
- **数据一致性验证**: 确保不同时间点获取的座位数据具有相同的映射逻辑

### 座位排数映射问题修复

#### 20. 问题现象与根因
- **用户反馈**: "现在的3排对应的是二排"
- **问题分析**: 
  - API返回的排数为非连续序列：[1, 3, 5, 7]
  - 原代码创建7行数组，按`rn-1`索引填充，导致存在空行
  - 界面按连续序号显示排数，但实际映射关系错乱

#### 21. 修复方案
**核心思路**: 创建紧凑的座位图，消除空行，建立正确的映射关系

**技术实现**:
1. **动态行数计算**: 使用`len(all_rows)`而非`max(all_rows)`作为行数
2. **排号映射表**: 创建`row_mapping = {api_row: ui_row}`映射字典
3. **双重排数保存**: 
   - `seat['row']`: 保存原始API排数（用于下单）
   - `seat['ui_row']`: 保存界面显示排数（用于显示）
4. **显示修复**: 座位图标签使用`seat['row']`而非连续序号

**修复前**:
```
API排数: [1, 3, 5, 7]
数组创建: 7行 (有空行)
界面显示: 1,2,3,4,5,6,7排
实际映射: 1排✓, 2排空, 3排✓, 4排空, 5排✓, 6排空, 7排✓
```

**修复后**:
```
API排数: [1, 3, 5, 7]  
数组创建: 4行 (无空行)
界面显示: 1,3,5,7排
实际映射: 1排✓, 3排✓, 5排✓, 7排✓
```

#### 22. 调试信息增强
- **映射关系输出**: 清晰显示API排数到界面排数的映射
- **关键座位跟踪**: 详细输出重要座位的映射过程
- **尺寸验证**: 确认最终seat_map的准确尺寸

#### 23. 用户体验改进
- **准确座位选择**: 用户点击的排数与实际下单排数完全一致
- **清晰排数显示**: 界面显示真实的影院排数，无虚假连续性
- **数据一致性**: 选座、下单、取票码各环节排数信息保持一致

### 座位显示UI优化

#### 24. 用户体验问题
- **用户反馈**: "应该显示的是1 2 3 4排，但是中间也是有隔开的"
- **需求分析**: 
  - 界面显示友好的连续排号（1, 2, 3, 4）提升可读性
  - 保持排与排之间的实际物理间距，体现真实影院布局
  - 确保显示排号与下单数据的正确映射

#### 25. 优化方案
**设计理念**: 显示友好 + 布局真实 + 数据准确

**技术实现**:
1. **连续排号显示**: 界面标签使用`r+1`显示为1, 2, 3, 4排
2. **按比例间距布局**: 根据API排号间距调整行间距
   ```python
   # API排号: [1, 3, 5, 7]，间距为2
   # 每个排号间隔增加8像素，体现物理间距
   gap_pixels = pad_y + (row_gap - 1) * 8
   ```
3. **双重排号管理**:
   - **显示排号**: `display_row = r + 1` （用于界面显示）
   - **API排号**: `seat['row']` （用于下单提交）

#### 26. 布局计算逻辑
**间距计算公式**:
```
y坐标 = 基础间距 + 行高 * 行号 + Σ(排号差值-1) * 额外间距
```

**示例效果**:
- API排号 [1, 3, 5, 7] → 界面显示 [1, 2, 3, 4]
- 第1排和第2排之间：正常间距 + (3-1-1) * 8px = 正常间距 + 8px
- 第2排和第3排之间：正常间距 + (5-3-1) * 8px = 正常间距 + 8px
- 第3排和第4排之间：正常间距 + (7-5-1) * 8px = 正常间距 + 8px

#### 27. 数据一致性保障
- **界面显示**: "1排5座" （用户友好）
- **下单数据**: 仍使用API原始排号 "3排5座" （数据准确）
- **调试输出**: 清晰显示映射关系
  ```
  [DEBUG] 座位显示: 2排5座 (API: 3排5座)
  ```

#### 28. 用户体验提升
- **直观排号**: 连续的1, 2, 3, 4排，符合用户认知习惯
- **真实布局**: 保持影院实际的排间距，增强空间感
- **操作一致**: 选座显示和下单提交数据完全准确
- **视觉优化**: 排间距差异化，避免视觉密集感

### 座位数据映射根本问题修复

#### 29. 问题发现与诊断
- **用户报告**: "现在的3排对应的是二排"，提交的是"2排5座"而不是"3排5座"
- **数据分析**: 通过对比小程序座位图接口和下单数据，发现关键问题
- **误解纠正**: 我们之前误认为需要提交真实排号`rn`字段，但实际上小程序接口期望的是数据行号`r`字段

#### 30. 接口数据结构真相
**座位图接口返回数据结构**:
```json
{
  "r": 2,    // 数据中的连续行号(1,2,3,4) - 这是接口期望的值！
  "rn": 3,   // 真实影院排号(1,3,5,7) - 仅用于物理位置参考
  "c": 5,    // 数据中的连续列号
  "cn": 5,   // 真实列号
  "sn": "000000011111-5-3"  // 座位编号
}
```

**下单接口期望数据**:
```json
{
  "seatRow": 2,           // 期望的是r字段值，不是rn字段值！
  "seatInfo": "2排5座",   // 界面友好显示
  "seatNo": "000000011111-5-3"  // 座位编号匹配
}
```

#### 31. 根本性修复
**修复策略**: 彻底重构座位数据处理逻辑

**关键修改**:
1. **数据源切换**: 从使用`rn`字段改为使用`r`字段作为排号基准
2. **映射简化**: 不再需要复杂的排号映射，直接使用API返回的`r`字段
3. **显示统一**: 界面显示和下单提交都使用相同的`r`字段值

**修复前后对比**:
```python
# 修复前（错误）
api_row = int(seat['rn'])  # 使用真实排号
seat['row'] = api_row      # 下单时提交真实排号
# 结果：界面显示2排，实际提交3排（错误）

# 修复后（正确）  
data_row = int(seat['r'])  # 使用数据行号
seat['row'] = data_row     # 下单时提交数据行号
# 结果：界面显示2排，实际提交2排（正确）
```

#### 32. 数据一致性保障
**完整数据保存**:
- `seat['row']`: 数据行号，用于界面显示和下单提交
- `seat['real_row']`: 真实排号，仅用于参考
- `seat['r']`: 原始r字段备份
- `seat['rn']`: 原始rn字段备份

**调试信息优化**:
```
[座位数据调试] 数据行号(r): [1, 2, 3, 4]
[座位数据调试] 真实排号(rn): [1, 3, 5, 7]
[DEBUG] 座位显示: 2排5座 (数据r=2, 真实rn=3)
```

#### 33. 修复验证结果
- **✅ 界面显示**: 2排5座（用户友好）
- **✅ 下单数据**: `seatRow: 2`（接口期望）
- **✅ 座位编号**: `seatNo: "000000011111-5-3"`（完全匹配）
- **✅ 数据一致**: 选座→显示→下单→取票全链路数据统一

#### 34. 经验总结
- **API理解**: 仔细分析接口期望的数据格式，不能凭主观推测
- **数据追踪**: 通过完整的接口数据对比发现问题根源  
- **调试重要性**: 详细的调试输出帮助快速定位问题
- **用户反馈价值**: 用户的直观反馈往往指向核心问题